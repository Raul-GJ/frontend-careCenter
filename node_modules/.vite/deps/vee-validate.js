// node_modules/vee-validate/dist/vee-validate.esm.js
var isTextInput = function(el) {
  return includes(["text", "password", "search", "email", "tel", "url", "textarea", "number"], el.type);
};
var isCheckboxOrRadioInput = function(el) {
  return includes(["radio", "checkbox"], el.type);
};
var isDateInput = function(el) {
  return includes(["date", "week", "month", "datetime-local", "time"], el.type);
};
var getDataAttribute = function(el, name) {
  return el.getAttribute("data-vv-" + name);
};
var isNaN$1 = function(value) {
  if ("isNaN" in Number) {
    return Number.isNaN(value);
  }
  return typeof value === "number" && value !== value;
};
var isNullOrUndefined = function() {
  var values2 = [], len = arguments.length;
  while (len--) values2[len] = arguments[len];
  return values2.every(function(value) {
    return value === null || value === void 0;
  });
};
var createFlags = function() {
  return {
    untouched: true,
    touched: false,
    dirty: false,
    pristine: true,
    valid: null,
    invalid: null,
    validated: false,
    pending: false,
    required: false,
    changed: false
  };
};
var isEqual = function(lhs, rhs) {
  if (lhs instanceof RegExp && rhs instanceof RegExp) {
    return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);
  }
  if (Array.isArray(lhs) && Array.isArray(rhs)) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    for (var i = 0; i < lhs.length; i++) {
      if (!isEqual(lhs[i], rhs[i])) {
        return false;
      }
    }
    return true;
  }
  if (isObject(lhs) && isObject(rhs)) {
    return Object.keys(lhs).every(function(key) {
      return isEqual(lhs[key], rhs[key]);
    }) && Object.keys(rhs).every(function(key) {
      return isEqual(lhs[key], rhs[key]);
    });
  }
  if (isNaN$1(lhs) && isNaN$1(rhs)) {
    return true;
  }
  return lhs === rhs;
};
var getScope = function(el) {
  var scope = getDataAttribute(el, "scope");
  if (isNullOrUndefined(scope)) {
    var form = getForm(el);
    if (form) {
      scope = getDataAttribute(form, "scope");
    }
  }
  return !isNullOrUndefined(scope) ? scope : null;
};
var getForm = function(el) {
  if (isNullOrUndefined(el)) {
    return null;
  }
  if (el.tagName === "FORM") {
    return el;
  }
  if (!isNullOrUndefined(el.form)) {
    return el.form;
  }
  return !isNullOrUndefined(el.parentNode) ? getForm(el.parentNode) : null;
};
var getPath = function(path, target, def) {
  if (def === void 0) def = void 0;
  if (!path || !target) {
    return def;
  }
  var value = target;
  path.split(".").every(function(prop) {
    if (prop in value) {
      value = value[prop];
      return true;
    }
    value = def;
    return false;
  });
  return value;
};
var hasPath = function(path, target) {
  var obj2 = target;
  var previousPath = null;
  var isNullOrNonObject = false;
  var isValidPath = path.split(".").reduce(function(reducer, prop) {
    if (obj2 == null || typeof obj2 !== "object") {
      isNullOrNonObject = true;
      return reducer && false;
    }
    if (prop in obj2) {
      obj2 = obj2[prop];
      previousPath = previousPath === null ? prop : previousPath + "." + prop;
      return reducer && true;
    }
    return reducer && false;
  }, true);
  if (true) {
    if (isNullOrNonObject) {
      throw new Error(previousPath + " is not an object");
    }
  }
  return isValidPath;
};
var parseRule = function(rule) {
  var params = [];
  var name = rule.split(":")[0];
  if (includes(rule, ":")) {
    params = rule.split(":").slice(1).join(":").split(",");
  }
  return { name, params };
};
var debounce = function(fn, wait, token) {
  if (wait === void 0) wait = 0;
  if (token === void 0) token = { cancelled: false };
  if (wait === 0) {
    return fn;
  }
  var timeout;
  return function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    var later = function() {
      timeout = null;
      if (!token.cancelled) {
        fn.apply(void 0, args);
      }
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (!timeout) {
      fn.apply(void 0, args);
    }
  };
};
var appendRule = function(rule, rules) {
  if (!rules) {
    return normalizeRules(rule);
  }
  if (!rule) {
    return normalizeRules(rules);
  }
  if (typeof rules === "string") {
    rules = normalizeRules(rules);
  }
  return assign({}, rules, normalizeRules(rule));
};
var normalizeRules = function(rules) {
  if (!rules) {
    return {};
  }
  if (isObject(rules)) {
    return Object.keys(rules).reduce(function(prev, curr) {
      var params = [];
      if (rules[curr] === true) {
        params = [];
      } else if (Array.isArray(rules[curr])) {
        params = rules[curr];
      } else if (isObject(rules[curr])) {
        params = rules[curr];
      } else {
        params = [rules[curr]];
      }
      if (rules[curr] !== false) {
        prev[curr] = params;
      }
      return prev;
    }, {});
  }
  if (typeof rules !== "string") {
    warn("rules must be either a string or an object.");
    return {};
  }
  return rules.split("|").reduce(function(prev, rule) {
    var parsedRule = parseRule(rule);
    if (!parsedRule.name) {
      return prev;
    }
    prev[parsedRule.name] = parsedRule.params;
    return prev;
  }, {});
};
var warn = function(message) {
  console.warn("[vee-validate] " + message);
};
var createError = function(message) {
  return new Error("[vee-validate] " + message);
};
var isObject = function(obj2) {
  return obj2 !== null && obj2 && typeof obj2 === "object" && !Array.isArray(obj2);
};
var isCallable = function(func) {
  return typeof func === "function";
};
var hasClass = function(el, className) {
  if (el.classList) {
    return el.classList.contains(className);
  }
  return !!el.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
};
var addClass = function(el, className) {
  if (el.classList) {
    el.classList.add(className);
    return;
  }
  if (!hasClass(el, className)) {
    el.className += " " + className;
  }
};
var removeClass = function(el, className) {
  if (el.classList) {
    el.classList.remove(className);
    return;
  }
  if (hasClass(el, className)) {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    el.className = el.className.replace(reg, " ");
  }
};
var toggleClass = function(el, className, status) {
  if (!el || !className) {
    return;
  }
  if (Array.isArray(className)) {
    className.forEach(function(item) {
      return toggleClass(el, item, status);
    });
    return;
  }
  if (status) {
    return addClass(el, className);
  }
  removeClass(el, className);
};
var toArray = function(arrayLike) {
  if (isCallable(Array.from)) {
    return Array.from(arrayLike);
  }
  var array = [];
  var length2 = arrayLike.length;
  for (var i = 0; i < length2; i++) {
    array.push(arrayLike[i]);
  }
  return array;
};
var ensureArray = function(arrayLike) {
  if (Array.isArray(arrayLike)) {
    return [].concat(arrayLike);
  }
  var array = toArray(arrayLike);
  return isEmptyArray(array) ? [arrayLike] : array;
};
var assign = function(target) {
  var others = [], len = arguments.length - 1;
  while (len-- > 0) others[len] = arguments[len + 1];
  if (isCallable(Object.assign)) {
    return Object.assign.apply(Object, [target].concat(others));
  }
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var to = Object(target);
  others.forEach(function(arg) {
    if (arg != null) {
      Object.keys(arg).forEach(function(key) {
        to[key] = arg[key];
      });
    }
  });
  return to;
};
var id = 0;
var idTemplate = "{id}";
var uniqId = function() {
  if (id >= 9999) {
    id = 0;
    idTemplate = idTemplate.replace("{id}", "_{id}");
  }
  id++;
  var newId = idTemplate.replace("{id}", String(id));
  return newId;
};
var findIndex = function(arrayLike, predicate) {
  var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return i;
    }
  }
  return -1;
};
var find = function(arrayLike, predicate) {
  var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);
  var idx = findIndex(array, predicate);
  return idx === -1 ? void 0 : array[idx];
};
var isBuiltInComponent = function(vnode) {
  if (!vnode) {
    return false;
  }
  var tag = vnode.componentOptions.tag;
  return /^(keep-alive|transition|transition-group)$/.test(tag);
};
var makeDelayObject = function(events, delay, delayConfig) {
  if (typeof delay === "number") {
    return events.reduce(function(prev, e) {
      prev[e] = delay;
      return prev;
    }, {});
  }
  return events.reduce(function(prev, e) {
    if (typeof delay === "object" && e in delay) {
      prev[e] = delay[e];
      return prev;
    }
    if (typeof delayConfig === "number") {
      prev[e] = delayConfig;
      return prev;
    }
    prev[e] = delayConfig && delayConfig[e] || 0;
    return prev;
  }, {});
};
var deepParseInt = function(input) {
  if (typeof input === "number") {
    return input;
  }
  if (typeof input === "string") {
    return parseInt(input);
  }
  var map2 = {};
  for (var element in input) {
    map2[element] = parseInt(input[element]);
  }
  return map2;
};
var merge = function(target, source) {
  if (!(isObject(target) && isObject(source))) {
    return target;
  }
  Object.keys(source).forEach(function(key) {
    var obj2, obj$1;
    if (isObject(source[key])) {
      if (!target[key]) {
        assign(target, (obj2 = {}, obj2[key] = {}, obj2));
      }
      merge(target[key], source[key]);
      return;
    }
    assign(target, (obj$1 = {}, obj$1[key] = source[key], obj$1));
  });
  return target;
};
var fillRulesFromElement = function(el, rules) {
  if (el.required) {
    rules = appendRule("required", rules);
  }
  if (isTextInput(el)) {
    if (el.type === "email") {
      rules = appendRule("email" + (el.multiple ? ":multiple" : ""), rules);
    }
    if (el.pattern) {
      rules = appendRule({ regex: el.pattern }, rules);
    }
    if (el.maxLength >= 0 && el.maxLength < 524288) {
      rules = appendRule("max:" + el.maxLength, rules);
    }
    if (el.minLength > 0) {
      rules = appendRule("min:" + el.minLength, rules);
    }
    if (el.type === "number") {
      rules = appendRule("decimal", rules);
      if (el.min !== "") {
        rules = appendRule("min_value:" + el.min, rules);
      }
      if (el.max !== "") {
        rules = appendRule("max_value:" + el.max, rules);
      }
    }
    return rules;
  }
  if (isDateInput(el)) {
    var timeFormat = el.step && Number(el.step) < 60 ? "HH:mm:ss" : "HH:mm";
    if (el.type === "date") {
      return appendRule("date_format:yyyy-MM-dd", rules);
    }
    if (el.type === "datetime-local") {
      return appendRule("date_format:yyyy-MM-ddT" + timeFormat, rules);
    }
    if (el.type === "month") {
      return appendRule("date_format:yyyy-MM", rules);
    }
    if (el.type === "week") {
      return appendRule("date_format:yyyy-[W]WW", rules);
    }
    if (el.type === "time") {
      return appendRule("date_format:" + timeFormat, rules);
    }
  }
  return rules;
};
var values = function(obj2) {
  if (isCallable(Object.values)) {
    return Object.values(obj2);
  }
  return Object.keys(obj2).map(function(k) {
    return obj2[k];
  });
};
var parseSelector = function(selector) {
  var rule = null;
  if (includes(selector, ":")) {
    rule = selector.split(":").pop();
    selector = selector.replace(":" + rule, "");
  }
  if (selector[0] === "#") {
    return {
      id: selector.slice(1),
      rule,
      name: null,
      scope: null
    };
  }
  var scope = null;
  var name = selector;
  if (includes(selector, ".")) {
    var parts = selector.split(".");
    scope = parts[0];
    name = parts.slice(1).join(".");
  }
  return {
    id: null,
    scope,
    name,
    rule
  };
};
var includes = function(collection, item) {
  return collection.indexOf(item) !== -1;
};
var isEmptyArray = function(arr) {
  return Array.isArray(arr) && arr.length === 0;
};
var defineNonReactive = function(obj2, prop, value) {
  Object.defineProperty(obj2, prop, {
    configurable: false,
    writable: true,
    value
  });
};
var LOCALE = "en";
var Dictionary = function Dictionary2(dictionary) {
  if (dictionary === void 0) dictionary = {};
  this.container = {};
  this.merge(dictionary);
};
var prototypeAccessors = { locale: { configurable: true } };
prototypeAccessors.locale.get = function() {
  return LOCALE;
};
prototypeAccessors.locale.set = function(value) {
  LOCALE = value || "en";
};
Dictionary.prototype.hasLocale = function hasLocale(locale2) {
  return !!this.container[locale2];
};
Dictionary.prototype.setDateFormat = function setDateFormat(locale2, format2) {
  if (!this.container[locale2]) {
    this.container[locale2] = {};
  }
  this.container[locale2].dateFormat = format2;
};
Dictionary.prototype.getDateFormat = function getDateFormat(locale2) {
  if (!this.container[locale2] || !this.container[locale2].dateFormat) {
    return null;
  }
  return this.container[locale2].dateFormat;
};
Dictionary.prototype.getMessage = function getMessage(locale2, key, data) {
  var message = null;
  if (!this.hasMessage(locale2, key)) {
    message = this._getDefaultMessage(locale2);
  } else {
    message = this.container[locale2].messages[key];
  }
  return isCallable(message) ? message.apply(void 0, data) : message;
};
Dictionary.prototype.getFieldMessage = function getFieldMessage(locale2, field, key, data) {
  if (!this.hasLocale(locale2)) {
    return this.getMessage(locale2, key, data);
  }
  var dict = this.container[locale2].custom && this.container[locale2].custom[field];
  if (!dict || !dict[key]) {
    return this.getMessage(locale2, key, data);
  }
  var message = dict[key];
  return isCallable(message) ? message.apply(void 0, data) : message;
};
Dictionary.prototype._getDefaultMessage = function _getDefaultMessage(locale2) {
  if (this.hasMessage(locale2, "_default")) {
    return this.container[locale2].messages._default;
  }
  return this.container.en.messages._default;
};
Dictionary.prototype.getAttribute = function getAttribute(locale2, key, fallback) {
  if (fallback === void 0) fallback = "";
  if (!this.hasAttribute(locale2, key)) {
    return fallback;
  }
  return this.container[locale2].attributes[key];
};
Dictionary.prototype.hasMessage = function hasMessage(locale2, key) {
  return !!(this.hasLocale(locale2) && this.container[locale2].messages && this.container[locale2].messages[key]);
};
Dictionary.prototype.hasAttribute = function hasAttribute(locale2, key) {
  return !!(this.hasLocale(locale2) && this.container[locale2].attributes && this.container[locale2].attributes[key]);
};
Dictionary.prototype.merge = function merge$1(dictionary) {
  merge(this.container, dictionary);
};
Dictionary.prototype.setMessage = function setMessage(locale2, key, message) {
  if (!this.hasLocale(locale2)) {
    this.container[locale2] = {
      messages: {},
      attributes: {}
    };
  }
  if (!this.container[locale2].messages) {
    this.container[locale2].messages = {};
  }
  this.container[locale2].messages[key] = message;
};
Dictionary.prototype.setAttribute = function setAttribute(locale2, key, attribute) {
  if (!this.hasLocale(locale2)) {
    this.container[locale2] = {
      messages: {},
      attributes: {}
    };
  }
  this.container[locale2].attributes[key] = attribute;
};
Object.defineProperties(Dictionary.prototype, prototypeAccessors);
var drivers = {
  default: new Dictionary({
    en: {
      messages: {},
      attributes: {},
      custom: {}
    }
  })
};
var currentDriver = "default";
var DictionaryResolver = function DictionaryResolver2() {
};
DictionaryResolver._checkDriverName = function _checkDriverName(driver) {
  if (!driver) {
    throw createError("you must provide a name to the dictionary driver");
  }
};
DictionaryResolver.setDriver = function setDriver(driver, implementation) {
  if (implementation === void 0) implementation = null;
  this._checkDriverName(driver);
  if (implementation) {
    drivers[driver] = implementation;
  }
  currentDriver = driver;
};
DictionaryResolver.getDriver = function getDriver() {
  return drivers[currentDriver];
};
var ErrorBag = function ErrorBag2(errorBag, id2) {
  if (errorBag === void 0) errorBag = null;
  if (id2 === void 0) id2 = null;
  this.vmId = id2 || null;
  if (errorBag && errorBag instanceof ErrorBag2) {
    this.items = errorBag.items;
  } else {
    this.items = [];
  }
};
ErrorBag.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function() {
  var this$1 = this;
  var index = 0;
  return {
    next: function() {
      return { value: this$1.items[index++], done: index > this$1.items.length };
    }
  };
};
ErrorBag.prototype.add = function add(error) {
  var ref;
  (ref = this.items).push.apply(
    ref,
    this._normalizeError(error)
  );
};
ErrorBag.prototype._normalizeError = function _normalizeError(error) {
  var this$1 = this;
  if (Array.isArray(error)) {
    return error.map(function(e) {
      e.scope = !isNullOrUndefined(e.scope) ? e.scope : null;
      e.vmId = !isNullOrUndefined(e.vmId) ? e.vmId : this$1.vmId || null;
      return e;
    });
  }
  error.scope = !isNullOrUndefined(error.scope) ? error.scope : null;
  error.vmId = !isNullOrUndefined(error.vmId) ? error.vmId : this.vmId || null;
  return [error];
};
ErrorBag.prototype.regenerate = function regenerate() {
  this.items.forEach(function(i) {
    i.msg = isCallable(i.regenerate) ? i.regenerate() : i.msg;
  });
};
ErrorBag.prototype.update = function update(id2, error) {
  var item = find(this.items, function(i) {
    return i.id === id2;
  });
  if (!item) {
    return;
  }
  var idx = this.items.indexOf(item);
  this.items.splice(idx, 1);
  item.scope = error.scope;
  this.items.push(item);
};
ErrorBag.prototype.all = function all(scope) {
  var this$1 = this;
  var filterFn = function(item) {
    var matchesScope = true;
    var matchesVM = true;
    if (!isNullOrUndefined(scope)) {
      matchesScope = item.scope === scope;
    }
    if (!isNullOrUndefined(this$1.vmId)) {
      matchesVM = item.vmId === this$1.vmId;
    }
    return matchesVM && matchesScope;
  };
  return this.items.filter(filterFn).map(function(e) {
    return e.msg;
  });
};
ErrorBag.prototype.any = function any(scope) {
  var this$1 = this;
  var filterFn = function(item) {
    var matchesScope = true;
    var matchesVM = true;
    if (!isNullOrUndefined(scope)) {
      matchesScope = item.scope === scope;
    }
    if (!isNullOrUndefined(this$1.vmId)) {
      matchesVM = item.vmId === this$1.vmId;
    }
    return matchesVM && matchesScope;
  };
  return !!this.items.filter(filterFn).length;
};
ErrorBag.prototype.clear = function clear(scope) {
  var this$1 = this;
  var matchesVM = isNullOrUndefined(this.vmId) ? function() {
    return true;
  } : function(i2) {
    return i2.vmId === this$1.vmId;
  };
  var matchesScope = function(i2) {
    return i2.scope === scope;
  };
  if (arguments.length === 0) {
    matchesScope = function() {
      return true;
    };
  } else if (isNullOrUndefined(scope)) {
    scope = null;
  }
  for (var i = 0; i < this.items.length; ++i) {
    if (matchesVM(this.items[i]) && matchesScope(this.items[i])) {
      this.items.splice(i, 1);
      --i;
    }
  }
};
ErrorBag.prototype.collect = function collect(field, scope, map2) {
  var this$1 = this;
  if (map2 === void 0) map2 = true;
  var isSingleField = !isNullOrUndefined(field) && !field.includes("*");
  var groupErrors = function(items) {
    var errors = items.reduce(function(collection, error) {
      if (!isNullOrUndefined(this$1.vmId) && error.vmId !== this$1.vmId) {
        return collection;
      }
      if (!collection[error.field]) {
        collection[error.field] = [];
      }
      collection[error.field].push(map2 ? error.msg : error);
      return collection;
    }, {});
    if (isSingleField) {
      return values(errors)[0] || [];
    }
    return errors;
  };
  if (isNullOrUndefined(field)) {
    return groupErrors(this.items);
  }
  var selector = isNullOrUndefined(scope) ? String(field) : scope + "." + field;
  var ref = this._makeCandidateFilters(selector);
  var isPrimary = ref.isPrimary;
  var isAlt = ref.isAlt;
  var collected = this.items.reduce(function(prev, curr) {
    if (isPrimary(curr)) {
      prev.primary.push(curr);
    }
    if (isAlt(curr)) {
      prev.alt.push(curr);
    }
    return prev;
  }, { primary: [], alt: [] });
  collected = collected.primary.length ? collected.primary : collected.alt;
  return groupErrors(collected);
};
ErrorBag.prototype.count = function count() {
  var this$1 = this;
  if (this.vmId) {
    return this.items.filter(function(e) {
      return e.vmId === this$1.vmId;
    }).length;
  }
  return this.items.length;
};
ErrorBag.prototype.firstById = function firstById(id2) {
  var error = find(this.items, function(i) {
    return i.id === id2;
  });
  return error ? error.msg : void 0;
};
ErrorBag.prototype.first = function first(field, scope) {
  if (scope === void 0) scope = null;
  var selector = isNullOrUndefined(scope) ? field : scope + "." + field;
  var match2 = this._match(selector);
  return match2 && match2.msg;
};
ErrorBag.prototype.firstRule = function firstRule(field, scope) {
  var errors = this.collect(field, scope, false);
  return errors.length && errors[0].rule || void 0;
};
ErrorBag.prototype.has = function has(field, scope) {
  if (scope === void 0) scope = null;
  return !!this.first(field, scope);
};
ErrorBag.prototype.firstByRule = function firstByRule(name, rule, scope) {
  if (scope === void 0) scope = null;
  var error = this.collect(name, scope, false).filter(function(e) {
    return e.rule === rule;
  })[0];
  return error && error.msg || void 0;
};
ErrorBag.prototype.firstNot = function firstNot(name, rule, scope) {
  if (rule === void 0) rule = "required";
  if (scope === void 0) scope = null;
  var error = this.collect(name, scope, false).filter(function(e) {
    return e.rule !== rule;
  })[0];
  return error && error.msg || void 0;
};
ErrorBag.prototype.removeById = function removeById(id2) {
  var condition = function(item) {
    return item.id === id2;
  };
  if (Array.isArray(id2)) {
    condition = function(item) {
      return id2.indexOf(item.id) !== -1;
    };
  }
  for (var i = 0; i < this.items.length; ++i) {
    if (condition(this.items[i])) {
      this.items.splice(i, 1);
      --i;
    }
  }
};
ErrorBag.prototype.remove = function remove(field, scope, vmId) {
  if (isNullOrUndefined(field)) {
    return;
  }
  var selector = isNullOrUndefined(scope) ? String(field) : scope + "." + field;
  var ref = this._makeCandidateFilters(selector);
  var isPrimary = ref.isPrimary;
  var isAlt = ref.isAlt;
  var matches2 = function(item) {
    return isPrimary(item) || isAlt(item);
  };
  var shouldRemove = function(item) {
    if (isNullOrUndefined(vmId)) {
      return matches2(item);
    }
    return matches2(item) && item.vmId === vmId;
  };
  for (var i = 0; i < this.items.length; ++i) {
    if (shouldRemove(this.items[i])) {
      this.items.splice(i, 1);
      --i;
    }
  }
};
ErrorBag.prototype._makeCandidateFilters = function _makeCandidateFilters(selector) {
  var this$1 = this;
  var matchesRule = function() {
    return true;
  };
  var matchesScope = function() {
    return true;
  };
  var matchesName = function() {
    return true;
  };
  var matchesVM = function() {
    return true;
  };
  var ref = parseSelector(selector);
  var id2 = ref.id;
  var rule = ref.rule;
  var scope = ref.scope;
  var name = ref.name;
  if (rule) {
    matchesRule = function(item) {
      return item.rule === rule;
    };
  }
  if (id2) {
    return {
      isPrimary: function(item) {
        return matchesRule(item) && function(item2) {
          return id2 === item2.id;
        };
      },
      isAlt: function() {
        return false;
      }
    };
  }
  if (isNullOrUndefined(scope)) {
    matchesScope = function(item) {
      return isNullOrUndefined(item.scope);
    };
  } else {
    matchesScope = function(item) {
      return item.scope === scope;
    };
  }
  if (!isNullOrUndefined(name) && name !== "*") {
    matchesName = function(item) {
      return item.field === name;
    };
  }
  if (!isNullOrUndefined(this.vmId)) {
    matchesVM = function(item) {
      return item.vmId === this$1.vmId;
    };
  }
  var isPrimary = function(item) {
    return matchesVM(item) && matchesName(item) && matchesRule(item) && matchesScope(item);
  };
  var isAlt = function(item) {
    return matchesVM(item) && matchesRule(item) && item.field === scope + "." + name;
  };
  return {
    isPrimary,
    isAlt
  };
};
ErrorBag.prototype._match = function _match(selector) {
  if (isNullOrUndefined(selector)) {
    return void 0;
  }
  var ref = this._makeCandidateFilters(selector);
  var isPrimary = ref.isPrimary;
  var isAlt = ref.isAlt;
  return this.items.reduce(function(prev, item, idx, arr) {
    var isLast = idx === arr.length - 1;
    if (prev.primary) {
      return isLast ? prev.primary : prev;
    }
    if (isPrimary(item)) {
      prev.primary = item;
    }
    if (isAlt(item)) {
      prev.alt = item;
    }
    if (!isLast) {
      return prev;
    }
    return prev.primary || prev.alt;
  }, {});
};
var DEFAULT_CONFIG = {
  locale: "en",
  delay: 0,
  errorBagName: "errors",
  dictionary: null,
  fieldsBagName: "fields",
  classes: false,
  classNames: null,
  events: "input",
  inject: true,
  fastExit: true,
  aria: true,
  validity: false,
  mode: "aggressive",
  useConstraintAttrs: true,
  i18n: null,
  i18nRootKey: "validation"
};
var currentConfig = assign({}, DEFAULT_CONFIG);
var resolveConfig = function(ctx2) {
  var selfConfig = getPath("$options.$_veeValidate", ctx2, {});
  return assign({}, currentConfig, selfConfig);
};
var getConfig = function() {
  return currentConfig;
};
var setConfig = function(newConf) {
  currentConfig = assign({}, currentConfig, newConf);
};
function findModel(vnode) {
  if (!vnode.data) {
    return null;
  }
  if (vnode.data.model) {
    return vnode.data.model;
  }
  return !!vnode.data.directives && find(vnode.data.directives, function(d) {
    return d.name === "model";
  });
}
function extractChildren(vnode) {
  if (Array.isArray(vnode)) {
    return vnode;
  }
  if (Array.isArray(vnode.children)) {
    return vnode.children;
  }
  if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {
    return vnode.componentOptions.children;
  }
  return [];
}
function extractVNodes(vnode) {
  if (findModel(vnode)) {
    return [vnode];
  }
  var children = extractChildren(vnode);
  return children.reduce(function(nodes, node) {
    var candidates = extractVNodes(node);
    if (candidates.length) {
      nodes.push.apply(nodes, candidates);
    }
    return nodes;
  }, []);
}
function findModelConfig(vnode) {
  if (!vnode.componentOptions) {
    return null;
  }
  return vnode.componentOptions.Ctor.options.model;
}
function mergeVNodeListeners(obj2, eventName, handler2) {
  if (isCallable(obj2[eventName])) {
    var prevHandler = obj2[eventName];
    obj2[eventName] = [prevHandler];
  }
  if (isNullOrUndefined(obj2[eventName])) {
    obj2[eventName] = [];
  }
  obj2[eventName].push(handler2);
}
function addNativeNodeListener(node, eventName, handler2) {
  if (isNullOrUndefined(node.data.on)) {
    node.data.on = {};
  }
  mergeVNodeListeners(node.data.on, eventName, handler2);
}
function addComponentNodeListener(node, eventName, handler2) {
  if (!node.componentOptions.listeners) {
    node.componentOptions.listeners = {};
  }
  mergeVNodeListeners(node.componentOptions.listeners, eventName, handler2);
}
function addVNodeListener(vnode, eventName, handler2) {
  if (vnode.componentOptions) {
    addComponentNodeListener(vnode, eventName, handler2);
    return;
  }
  addNativeNodeListener(vnode, eventName, handler2);
}
function getInputEventName(vnode, model) {
  if (vnode.componentOptions) {
    var ref = findModelConfig(vnode) || { event: "input" };
    var event = ref.event;
    return event;
  }
  if (model && model.modifiers && model.modifiers.lazy || vnode.tag === "select") {
    return "change";
  }
  if (vnode.data.attrs && isTextInput({ type: vnode.data.attrs.type || "text" })) {
    return "input";
  }
  return "change";
}
function normalizeSlots(slots, ctx2) {
  return Object.keys(slots).reduce(function(arr, key) {
    slots[key].forEach(function(vnode) {
      if (!vnode.context) {
        slots[key].context = ctx2;
        if (!vnode.data) {
          vnode.data = {};
        }
        vnode.data.slot = key;
      }
    });
    return arr.concat(slots[key]);
  }, []);
}
function createRenderless(h, children) {
  if (Array.isArray(children) && children[0]) {
    return children[0];
  }
  if (children) {
    return children;
  }
  return h();
}
var Resolver = function Resolver2() {
};
Resolver.generate = function generate(el, binding, vnode) {
  var model = Resolver.resolveModel(binding, vnode);
  var options2 = resolveConfig(vnode.context);
  return {
    name: Resolver.resolveName(el, vnode),
    el,
    listen: !binding.modifiers.disable,
    bails: binding.modifiers.bails ? true : binding.modifiers.continues === true ? false : void 0,
    scope: Resolver.resolveScope(el, binding, vnode),
    vm: vnode.context,
    expression: binding.value,
    component: vnode.componentInstance,
    classes: options2.classes,
    classNames: options2.classNames,
    getter: Resolver.resolveGetter(el, vnode, model),
    events: Resolver.resolveEvents(el, vnode) || options2.events,
    model,
    delay: Resolver.resolveDelay(el, vnode, options2),
    rules: Resolver.resolveRules(el, binding, vnode),
    immediate: !!binding.modifiers.initial || !!binding.modifiers.immediate,
    persist: !!binding.modifiers.persist,
    validity: options2.validity && !vnode.componentInstance,
    aria: options2.aria && !vnode.componentInstance,
    initialValue: Resolver.resolveInitialValue(vnode)
  };
};
Resolver.getCtorConfig = function getCtorConfig(vnode) {
  if (!vnode.componentInstance) {
    return null;
  }
  var config = getPath("componentInstance.$options.$_veeValidate", vnode);
  return config;
};
Resolver.resolveRules = function resolveRules(el, binding, vnode) {
  var rules = "";
  if (!binding.value && (!binding || !binding.expression)) {
    rules = getDataAttribute(el, "rules");
  }
  if (binding.value && includes(["string", "object"], typeof binding.value.rules)) {
    rules = binding.value.rules;
  } else if (binding.value) {
    rules = binding.value;
  }
  if (vnode.componentInstance) {
    return rules;
  }
  var normalized = normalizeRules(rules);
  if (!getConfig().useConstraintAttrs) {
    return normalized;
  }
  return assign({}, fillRulesFromElement(el, {}), normalized);
};
Resolver.resolveInitialValue = function resolveInitialValue(vnode) {
  var model = vnode.data.model || find(vnode.data.directives, function(d) {
    return d.name === "model";
  });
  return model && model.value;
};
Resolver.resolveDelay = function resolveDelay(el, vnode, options2) {
  var delay = getDataAttribute(el, "delay");
  var globalDelay = options2 && "delay" in options2 ? options2.delay : 0;
  if (!delay && vnode.componentInstance && vnode.componentInstance.$attrs) {
    delay = vnode.componentInstance.$attrs["data-vv-delay"];
  }
  if (!isObject(globalDelay)) {
    return deepParseInt(delay || globalDelay);
  }
  if (!isNullOrUndefined(delay)) {
    globalDelay.input = delay;
  }
  return deepParseInt(globalDelay);
};
Resolver.resolveEvents = function resolveEvents(el, vnode) {
  var events = getDataAttribute(el, "validate-on");
  if (!events && vnode.componentInstance && vnode.componentInstance.$attrs) {
    events = vnode.componentInstance.$attrs["data-vv-validate-on"];
  }
  if (!events && vnode.componentInstance) {
    var config = Resolver.getCtorConfig(vnode);
    events = config && config.events;
  }
  if (!events && getConfig().events) {
    events = getConfig().events;
  }
  if (events && vnode.componentInstance && includes(events, "input")) {
    var ref = vnode.componentInstance.$options.model || { event: "input" };
    var event = ref.event;
    if (!event) {
      return events;
    }
    events = events.replace("input", event);
  }
  return events;
};
Resolver.resolveScope = function resolveScope(el, binding, vnode) {
  if (vnode === void 0) vnode = {};
  var scope = null;
  if (vnode.componentInstance && isNullOrUndefined(scope)) {
    scope = vnode.componentInstance.$attrs && vnode.componentInstance.$attrs["data-vv-scope"];
  }
  return !isNullOrUndefined(scope) ? scope : getScope(el);
};
Resolver.resolveModel = function resolveModel(binding, vnode) {
  if (binding.arg) {
    return { expression: binding.arg };
  }
  var model = findModel(vnode);
  if (!model) {
    return null;
  }
  var watchable = !/[^\w.$]/.test(model.expression) && hasPath(model.expression, vnode.context);
  var lazy2 = !!(model.modifiers && model.modifiers.lazy);
  if (!watchable) {
    return { expression: null, lazy: lazy2 };
  }
  return { expression: model.expression, lazy: lazy2 };
};
Resolver.resolveName = function resolveName(el, vnode) {
  var name = getDataAttribute(el, "name");
  if (!name && !vnode.componentInstance) {
    return el.name;
  }
  if (!name && vnode.componentInstance && vnode.componentInstance.$attrs) {
    name = vnode.componentInstance.$attrs["data-vv-name"] || vnode.componentInstance.$attrs["name"];
  }
  if (!name && vnode.componentInstance) {
    var config = Resolver.getCtorConfig(vnode);
    if (config && isCallable(config.name)) {
      var boundGetter = config.name.bind(vnode.componentInstance);
      return boundGetter();
    }
    return vnode.componentInstance.name;
  }
  return name;
};
Resolver.resolveGetter = function resolveGetter(el, vnode, model) {
  if (model && model.expression) {
    return function() {
      return getPath(model.expression, vnode.context);
    };
  }
  if (vnode.componentInstance) {
    var path = getDataAttribute(el, "value-path") || vnode.componentInstance.$attrs && vnode.componentInstance.$attrs["data-vv-value-path"];
    if (path) {
      return function() {
        return getPath(path, vnode.componentInstance);
      };
    }
    var config = Resolver.getCtorConfig(vnode);
    if (config && isCallable(config.value)) {
      var boundGetter = config.value.bind(vnode.componentInstance);
      return function() {
        return boundGetter();
      };
    }
    var ref = vnode.componentInstance.$options.model || { prop: "value" };
    var prop = ref.prop;
    return function() {
      return vnode.componentInstance[prop];
    };
  }
  switch (el.type) {
    case "checkbox":
      return function() {
        var els = document.querySelectorAll('input[name="' + el.name + '"]');
        els = toArray(els).filter(function(el2) {
          return el2.checked;
        });
        if (!els.length) {
          return void 0;
        }
        return els.map(function(checkbox) {
          return checkbox.value;
        });
      };
    case "radio":
      return function() {
        var els = document.querySelectorAll('input[name="' + el.name + '"]');
        var elm = find(els, function(el2) {
          return el2.checked;
        });
        return elm && elm.value;
      };
    case "file":
      return function(context) {
        return toArray(el.files);
      };
    case "select-multiple":
      return function() {
        return toArray(el.options).filter(function(opt) {
          return opt.selected;
        }).map(function(opt) {
          return opt.value;
        });
      };
    default:
      return function() {
        return el && el.value;
      };
  }
};
var RULES = {};
var RuleContainer = function RuleContainer2() {
};
var staticAccessors = { rules: { configurable: true } };
RuleContainer.add = function add2(name, ref) {
  var validate6 = ref.validate;
  var options2 = ref.options;
  var paramNames2 = ref.paramNames;
  RULES[name] = {
    validate: validate6,
    options: options2,
    paramNames: paramNames2
  };
};
staticAccessors.rules.get = function() {
  return RULES;
};
RuleContainer.has = function has2(name) {
  return !!RULES[name];
};
RuleContainer.isImmediate = function isImmediate(name) {
  return !!(RULES[name] && RULES[name].options.immediate);
};
RuleContainer.isRequireRule = function isRequireRule(name) {
  return !!(RULES[name] && RULES[name].options.computesRequired);
};
RuleContainer.isTargetRule = function isTargetRule(name) {
  return !!(RULES[name] && RULES[name].options.hasTarget);
};
RuleContainer.remove = function remove2(ruleName) {
  delete RULES[ruleName];
};
RuleContainer.getParamNames = function getParamNames(ruleName) {
  return RULES[ruleName] && RULES[ruleName].paramNames;
};
RuleContainer.getOptions = function getOptions(ruleName) {
  return RULES[ruleName] && RULES[ruleName].options;
};
RuleContainer.getValidatorMethod = function getValidatorMethod(ruleName) {
  return RULES[ruleName] ? RULES[ruleName].validate : null;
};
Object.defineProperties(RuleContainer, staticAccessors);
var isEvent = function(evt) {
  return typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event || evt && evt.srcElement;
};
var normalizeEvents = function(evts) {
  if (!evts) {
    return [];
  }
  return typeof evts === "string" ? evts.split("|") : evts;
};
var supportsPassive = true;
var detectPassiveSupport = function() {
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("testPassive", null, opts);
    window.removeEventListener("testPassive", null, opts);
  } catch (e) {
    supportsPassive = false;
  }
  return supportsPassive;
};
var addEventListener = function(el, eventName, cb) {
  el.addEventListener(eventName, cb, supportsPassive ? { passive: true } : false);
};
var DEFAULT_OPTIONS = {
  targetOf: null,
  immediate: false,
  persist: false,
  scope: null,
  listen: true,
  name: null,
  rules: {},
  vm: null,
  classes: false,
  validity: true,
  aria: true,
  events: "input|blur",
  delay: 0,
  classNames: {
    touched: "touched",
    // the control has been blurred
    untouched: "untouched",
    // the control hasn't been blurred
    valid: "valid",
    // model is valid
    invalid: "invalid",
    // model is invalid
    pristine: "pristine",
    // control has not been interacted with
    dirty: "dirty"
    // control has been interacted with
  }
};
var Field = function Field2(options2) {
  if (options2 === void 0) options2 = {};
  this.id = uniqId();
  this.el = options2.el;
  this.updated = false;
  this.vmId = options2.vmId;
  defineNonReactive(this, "dependencies", []);
  defineNonReactive(this, "watchers", []);
  defineNonReactive(this, "events", []);
  this.delay = 0;
  this.rules = {};
  this.forceRequired = false;
  this._cacheId(options2);
  this.classNames = assign({}, DEFAULT_OPTIONS.classNames);
  options2 = assign({}, DEFAULT_OPTIONS, options2);
  this._delay = !isNullOrUndefined(options2.delay) ? options2.delay : 0;
  this.validity = options2.validity;
  this.aria = options2.aria;
  this.flags = options2.flags || createFlags();
  defineNonReactive(this, "vm", options2.vm);
  defineNonReactive(this, "componentInstance", options2.component);
  this.ctorConfig = this.componentInstance ? getPath("$options.$_veeValidate", this.componentInstance) : void 0;
  this.update(options2);
  this.initialValue = this.value;
  this.updated = false;
};
var prototypeAccessors$1 = { validator: { configurable: true }, isRequired: { configurable: true }, isDisabled: { configurable: true }, alias: { configurable: true }, value: { configurable: true }, bails: { configurable: true }, rejectsFalse: { configurable: true } };
prototypeAccessors$1.validator.get = function() {
  if (!this.vm || !this.vm.$validator) {
    return { validate: function() {
      return Promise.resolve(true);
    } };
  }
  return this.vm.$validator;
};
prototypeAccessors$1.isRequired.get = function() {
  return !!this.rules.required || this.forceRequired;
};
prototypeAccessors$1.isDisabled.get = function() {
  return !!(this.el && this.el.disabled);
};
prototypeAccessors$1.alias.get = function() {
  if (this._alias) {
    return this._alias;
  }
  var alias = null;
  if (this.ctorConfig && this.ctorConfig.alias) {
    alias = isCallable(this.ctorConfig.alias) ? this.ctorConfig.alias.call(this.componentInstance) : this.ctorConfig.alias;
  }
  if (!alias && this.el) {
    alias = getDataAttribute(this.el, "as");
  }
  if (!alias && this.componentInstance) {
    return this.componentInstance.$attrs && this.componentInstance.$attrs["data-vv-as"];
  }
  return alias;
};
prototypeAccessors$1.value.get = function() {
  if (!isCallable(this.getter)) {
    return void 0;
  }
  return this.getter();
};
prototypeAccessors$1.bails.get = function() {
  return this._bails;
};
prototypeAccessors$1.rejectsFalse.get = function() {
  if (this.componentInstance && this.ctorConfig) {
    return !!this.ctorConfig.rejectsFalse;
  }
  if (!this.el) {
    return false;
  }
  return this.el.type === "checkbox";
};
Field.prototype.matches = function matches(options2) {
  var this$1 = this;
  if (!options2) {
    return true;
  }
  if (options2.id) {
    return this.id === options2.id;
  }
  var matchesComponentId = isNullOrUndefined(options2.vmId) ? function() {
    return true;
  } : function(id2) {
    return id2 === this$1.vmId;
  };
  if (!matchesComponentId(options2.vmId)) {
    return false;
  }
  if (options2.name === void 0 && options2.scope === void 0) {
    return true;
  }
  if (options2.scope === void 0) {
    return this.name === options2.name;
  }
  if (options2.name === void 0) {
    return this.scope === options2.scope;
  }
  return options2.name === this.name && options2.scope === this.scope;
};
Field.prototype._cacheId = function _cacheId(options2) {
  if (this.el && !options2.targetOf) {
    this.el._veeValidateId = this.id;
  }
};
Field.prototype.waitFor = function waitFor(pendingPromise) {
  this._waitingFor = pendingPromise;
};
Field.prototype.isWaitingFor = function isWaitingFor(promise) {
  return this._waitingFor === promise;
};
Field.prototype.update = function update2(options2) {
  var this$1 = this;
  this.targetOf = options2.targetOf || null;
  this.immediate = options2.immediate || this.immediate || false;
  this.persist = options2.persist || this.persist || false;
  if (!isNullOrUndefined(options2.scope) && options2.scope !== this.scope && isCallable(this.validator.update)) {
    this.validator.update(this.id, { scope: options2.scope });
  }
  this.scope = !isNullOrUndefined(options2.scope) ? options2.scope : !isNullOrUndefined(this.scope) ? this.scope : null;
  this.name = (!isNullOrUndefined(options2.name) ? String(options2.name) : options2.name) || this.name || null;
  this.rules = options2.rules !== void 0 ? normalizeRules(options2.rules) : this.rules;
  this._bails = options2.bails !== void 0 ? options2.bails : this._bails;
  this.model = options2.model || this.model;
  this.listen = options2.listen !== void 0 ? options2.listen : this.listen;
  this.classes = (options2.classes || this.classes || false) && !this.componentInstance;
  this.classNames = isObject(options2.classNames) ? merge(this.classNames, options2.classNames) : this.classNames;
  this.getter = isCallable(options2.getter) ? options2.getter : this.getter;
  this._alias = options2.alias || this._alias;
  this.events = options2.events ? normalizeEvents(options2.events) : this.events;
  this.delay = makeDelayObject(this.events, options2.delay || this.delay, this._delay);
  this.updateDependencies();
  this.addActionListeners();
  if (!this.name && !this.targetOf) {
    warn('A field is missing a "name" or "data-vv-name" attribute');
  }
  if (options2.rules !== void 0) {
    this.flags.required = this.isRequired;
  }
  if (Object.keys(options2.rules || {}).length === 0 && this.updated) {
    var resetFlag = this.flags.validated;
    this.validator.validate("#" + this.id).then(function() {
      this$1.flags.validated = resetFlag;
    });
  }
  if (this.flags.validated && options2.rules !== void 0 && this.updated) {
    this.validator.validate("#" + this.id);
  }
  this.updated = true;
  this.addValueListeners();
  if (!this.el) {
    return;
  }
  this.updateClasses();
  this.updateAriaAttrs();
};
Field.prototype.reset = function reset() {
  var this$1 = this;
  if (this._cancellationToken) {
    this._cancellationToken.cancelled = true;
    delete this._cancellationToken;
  }
  var defaults = createFlags();
  Object.keys(this.flags).filter(function(flag3) {
    return flag3 !== "required";
  }).forEach(function(flag3) {
    this$1.flags[flag3] = defaults[flag3];
  });
  this.initialValue = this.value;
  this.flags.changed = false;
  this.addValueListeners();
  this.addActionListeners();
  this.updateClasses(true);
  this.updateAriaAttrs();
  this.updateCustomValidity();
};
Field.prototype.setFlags = function setFlags(flags) {
  var this$1 = this;
  var negated = {
    pristine: "dirty",
    dirty: "pristine",
    valid: "invalid",
    invalid: "valid",
    touched: "untouched",
    untouched: "touched"
  };
  Object.keys(flags).forEach(function(flag3) {
    this$1.flags[flag3] = flags[flag3];
    if (negated[flag3] && flags[negated[flag3]] === void 0) {
      this$1.flags[negated[flag3]] = !flags[flag3];
    }
  });
  if (flags.untouched !== void 0 || flags.touched !== void 0 || flags.dirty !== void 0 || flags.pristine !== void 0) {
    this.addActionListeners();
  }
  this.updateClasses();
  this.updateAriaAttrs();
  this.updateCustomValidity();
};
Field.prototype.updateDependencies = function updateDependencies() {
  var this$1 = this;
  this.dependencies.forEach(function(d) {
    return d.field.destroy();
  });
  this.dependencies = [];
  var fields = Object.keys(this.rules).reduce(function(prev, r) {
    if (RuleContainer.isTargetRule(r)) {
      prev.push({ selector: this$1.rules[r][0], name: r });
    }
    return prev;
  }, []);
  if (!fields.length || !this.vm || !this.vm.$el) {
    return;
  }
  fields.forEach(function(ref$1) {
    var selector = ref$1.selector;
    var name = ref$1.name;
    var ref = this$1.vm.$refs[selector];
    var el = Array.isArray(ref) ? ref[0] : ref;
    if (!el) {
      return;
    }
    var options2 = {
      vm: this$1.vm,
      classes: this$1.classes,
      classNames: this$1.classNames,
      delay: this$1.delay,
      scope: this$1.scope,
      events: this$1.events.join("|"),
      immediate: this$1.immediate,
      targetOf: this$1.id
    };
    if (isCallable(el.$watch)) {
      options2.component = el;
      options2.el = el.$el;
      options2.getter = Resolver.resolveGetter(el.$el, el.$vnode);
    } else {
      options2.el = el;
      options2.getter = Resolver.resolveGetter(el, {});
    }
    this$1.dependencies.push({ name, field: new Field(options2) });
  });
};
Field.prototype.unwatch = function unwatch(tag) {
  if (tag === void 0) tag = null;
  if (!tag) {
    this.watchers.forEach(function(w) {
      return w.unwatch();
    });
    this.watchers = [];
    return;
  }
  this.watchers.filter(function(w) {
    return tag.test(w.tag);
  }).forEach(function(w) {
    return w.unwatch();
  });
  this.watchers = this.watchers.filter(function(w) {
    return !tag.test(w.tag);
  });
};
Field.prototype.updateClasses = function updateClasses(isReset) {
  var this$1 = this;
  if (isReset === void 0) isReset = false;
  if (!this.classes || this.isDisabled) {
    return;
  }
  var applyClasses = function(el) {
    toggleClass(el, this$1.classNames.dirty, this$1.flags.dirty);
    toggleClass(el, this$1.classNames.pristine, this$1.flags.pristine);
    toggleClass(el, this$1.classNames.touched, this$1.flags.touched);
    toggleClass(el, this$1.classNames.untouched, this$1.flags.untouched);
    if (isReset) {
      toggleClass(el, this$1.classNames.valid, false);
      toggleClass(el, this$1.classNames.invalid, false);
    }
    if (!isNullOrUndefined(this$1.flags.valid) && this$1.flags.validated) {
      toggleClass(el, this$1.classNames.valid, this$1.flags.valid);
    }
    if (!isNullOrUndefined(this$1.flags.invalid) && this$1.flags.validated) {
      toggleClass(el, this$1.classNames.invalid, this$1.flags.invalid);
    }
  };
  if (!isCheckboxOrRadioInput(this.el)) {
    applyClasses(this.el);
    return;
  }
  var els = document.querySelectorAll('input[name="' + this.el.name + '"]');
  toArray(els).forEach(applyClasses);
};
Field.prototype.addActionListeners = function addActionListeners() {
  var this$1 = this;
  this.unwatch(/class/);
  if (!this.el) {
    return;
  }
  var onBlur = function() {
    this$1.flags.touched = true;
    this$1.flags.untouched = false;
    if (this$1.classes) {
      toggleClass(this$1.el, this$1.classNames.touched, true);
      toggleClass(this$1.el, this$1.classNames.untouched, false);
    }
    this$1.unwatch(/^class_blur$/);
  };
  var inputEvent = isTextInput(this.el) ? "input" : "change";
  var onInput = function() {
    this$1.flags.dirty = true;
    this$1.flags.pristine = false;
    if (this$1.classes) {
      toggleClass(this$1.el, this$1.classNames.pristine, false);
      toggleClass(this$1.el, this$1.classNames.dirty, true);
    }
    this$1.unwatch(/^class_input$/);
  };
  if (this.componentInstance && isCallable(this.componentInstance.$once)) {
    this.componentInstance.$once("input", onInput);
    this.componentInstance.$once("blur", onBlur);
    this.watchers.push({
      tag: "class_input",
      unwatch: function() {
        this$1.componentInstance.$off("input", onInput);
      }
    });
    this.watchers.push({
      tag: "class_blur",
      unwatch: function() {
        this$1.componentInstance.$off("blur", onBlur);
      }
    });
    return;
  }
  if (!this.el) {
    return;
  }
  addEventListener(this.el, inputEvent, onInput);
  var blurEvent = isCheckboxOrRadioInput(this.el) ? "change" : "blur";
  addEventListener(this.el, blurEvent, onBlur);
  this.watchers.push({
    tag: "class_input",
    unwatch: function() {
      this$1.el.removeEventListener(inputEvent, onInput);
    }
  });
  this.watchers.push({
    tag: "class_blur",
    unwatch: function() {
      this$1.el.removeEventListener(blurEvent, onBlur);
    }
  });
};
Field.prototype.checkValueChanged = function checkValueChanged() {
  if (this.initialValue === null && this.value === "" && isTextInput(this.el)) {
    return false;
  }
  return this.value !== this.initialValue;
};
Field.prototype._determineInputEvent = function _determineInputEvent() {
  if (this.componentInstance) {
    return this.componentInstance.$options.model && this.componentInstance.$options.model.event || "input";
  }
  if (this.model && this.model.lazy) {
    return "change";
  }
  if (isTextInput(this.el)) {
    return "input";
  }
  return "change";
};
Field.prototype._determineEventList = function _determineEventList(defaultInputEvent) {
  var this$1 = this;
  if (!this.events.length || this.componentInstance || isTextInput(this.el)) {
    return [].concat(this.events).map(function(evt) {
      if (evt === "input" && this$1.model && this$1.model.lazy) {
        return "change";
      }
      return evt;
    });
  }
  return this.events.map(function(e) {
    if (e === "input") {
      return defaultInputEvent;
    }
    return e;
  });
};
Field.prototype.addValueListeners = function addValueListeners() {
  var this$1 = this;
  this.unwatch(/^input_.+/);
  if (!this.listen || !this.el) {
    return;
  }
  var token = { cancelled: false };
  var fn = this.targetOf ? function() {
    var target = this$1.validator._resolveField("#" + this$1.targetOf);
    if (target && target.flags.validated) {
      this$1.validator.validate("#" + this$1.targetOf);
    }
  } : function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    if (args.length === 0 || isEvent(args[0])) {
      args[0] = this$1.value;
    }
    this$1.flags.pending = true;
    this$1._cancellationToken = token;
    this$1.validator.validate("#" + this$1.id, args[0]);
  };
  var inputEvent = this._determineInputEvent();
  var events = this._determineEventList(inputEvent);
  if (includes(events, inputEvent)) {
    var ctx2 = null;
    var expression = null;
    var watchCtxVm = false;
    if (this.model && this.model.expression) {
      ctx2 = this.vm;
      expression = this.model.expression;
      watchCtxVm = true;
    }
    if (!expression && this.componentInstance && this.componentInstance.$options.model) {
      ctx2 = this.componentInstance;
      expression = this.componentInstance.$options.model.prop || "value";
    }
    if (ctx2 && expression) {
      var debouncedFn = debounce(fn, this.delay[inputEvent], token);
      var unwatch2 = ctx2.$watch(expression, debouncedFn);
      this.watchers.push({
        tag: "input_model",
        unwatch: function() {
          this$1.vm.$nextTick(function() {
            unwatch2();
          });
        }
      });
      if (watchCtxVm) {
        events = events.filter(function(e) {
          return e !== inputEvent;
        });
      }
    }
  }
  events.forEach(function(e) {
    var debouncedFn2 = debounce(fn, this$1.delay[e], token);
    this$1._addComponentEventListener(e, debouncedFn2);
    this$1._addHTMLEventListener(e, debouncedFn2);
  });
};
Field.prototype._addComponentEventListener = function _addComponentEventListener(evt, validate6) {
  var this$1 = this;
  if (!this.componentInstance) {
    return;
  }
  this.componentInstance.$on(evt, validate6);
  this.watchers.push({
    tag: "input_vue",
    unwatch: function() {
      this$1.componentInstance.$off(evt, validate6);
    }
  });
};
Field.prototype._addHTMLEventListener = function _addHTMLEventListener(evt, validate6) {
  var this$1 = this;
  if (!this.el || this.componentInstance) {
    return;
  }
  var addListener = function(el) {
    addEventListener(el, evt, validate6);
    this$1.watchers.push({
      tag: "input_native",
      unwatch: function() {
        el.removeEventListener(evt, validate6);
      }
    });
  };
  addListener(this.el);
  if (!isCheckboxOrRadioInput(this.el)) {
    return;
  }
  var els = document.querySelectorAll('input[name="' + this.el.name + '"]');
  toArray(els).forEach(function(el) {
    if (el._veeValidateId && el !== this$1.el) {
      return;
    }
    addListener(el);
  });
};
Field.prototype.updateAriaAttrs = function updateAriaAttrs() {
  var this$1 = this;
  if (!this.aria || !this.el || !isCallable(this.el.setAttribute)) {
    return;
  }
  var applyAriaAttrs = function(el) {
    el.setAttribute("aria-required", this$1.isRequired ? "true" : "false");
    el.setAttribute("aria-invalid", this$1.flags.invalid ? "true" : "false");
  };
  if (!isCheckboxOrRadioInput(this.el)) {
    applyAriaAttrs(this.el);
    return;
  }
  var els = document.querySelectorAll('input[name="' + this.el.name + '"]');
  toArray(els).forEach(applyAriaAttrs);
};
Field.prototype.updateCustomValidity = function updateCustomValidity() {
  if (!this.validity || !this.el || !isCallable(this.el.setCustomValidity) || !this.validator.errors) {
    return;
  }
  this.el.setCustomValidity(this.flags.valid ? "" : this.validator.errors.firstById(this.id) || "");
};
Field.prototype.destroy = function destroy() {
  if (this._cancellationToken) {
    this._cancellationToken.cancelled = true;
  }
  this.unwatch();
  this.dependencies.forEach(function(d) {
    return d.field.destroy();
  });
  this.dependencies = [];
};
Object.defineProperties(Field.prototype, prototypeAccessors$1);
var FieldBag = function FieldBag2(items) {
  if (items === void 0) items = [];
  this.items = items || [];
  this.itemsById = this.items.reduce(function(itemsById, item) {
    itemsById[item.id] = item;
    return itemsById;
  }, {});
};
var prototypeAccessors$2 = { length: { configurable: true } };
FieldBag.prototype[typeof Symbol === "function" ? Symbol.iterator : "@@iterator"] = function() {
  var this$1 = this;
  var index = 0;
  return {
    next: function() {
      return { value: this$1.items[index++], done: index > this$1.items.length };
    }
  };
};
prototypeAccessors$2.length.get = function() {
  return this.items.length;
};
FieldBag.prototype.find = function find$1(matcher) {
  return find(this.items, function(item) {
    return item.matches(matcher);
  });
};
FieldBag.prototype.findById = function findById(id2) {
  return this.itemsById[id2] || null;
};
FieldBag.prototype.filter = function filter(matcher) {
  if (Array.isArray(matcher)) {
    return this.items.filter(function(item) {
      return matcher.some(function(m) {
        return item.matches(m);
      });
    });
  }
  return this.items.filter(function(item) {
    return item.matches(matcher);
  });
};
FieldBag.prototype.map = function map(mapper) {
  return this.items.map(mapper);
};
FieldBag.prototype.remove = function remove3(matcher) {
  var item = null;
  if (matcher instanceof Field) {
    item = matcher;
  } else {
    item = this.find(matcher);
  }
  if (!item) {
    return null;
  }
  var index = this.items.indexOf(item);
  this.items.splice(index, 1);
  delete this.itemsById[item.id];
  return item;
};
FieldBag.prototype.push = function push(item) {
  if (!(item instanceof Field)) {
    throw createError("FieldBag only accepts instances of Field that has an id defined.");
  }
  if (!item.id) {
    throw createError("Field id must be defined.");
  }
  if (this.findById(item.id)) {
    throw createError("Field with id " + item.id + " is already added.");
  }
  this.items.push(item);
  this.itemsById[item.id] = item;
};
Object.defineProperties(FieldBag.prototype, prototypeAccessors$2);
var ScopedValidator = function ScopedValidator2(base, vm) {
  this.id = vm._uid;
  this._base = base;
  this._paused = false;
  this.errors = new ErrorBag(base.errors, this.id);
};
var prototypeAccessors$3 = { flags: { configurable: true }, rules: { configurable: true }, fields: { configurable: true }, dictionary: { configurable: true }, locale: { configurable: true } };
prototypeAccessors$3.flags.get = function() {
  var this$1 = this;
  return this._base.fields.items.filter(function(f) {
    return f.vmId === this$1.id;
  }).reduce(function(acc, field) {
    if (field.scope) {
      if (!acc["$" + field.scope]) {
        acc["$" + field.scope] = {};
      }
      acc["$" + field.scope][field.name] = field.flags;
    }
    acc[field.name] = field.flags;
    return acc;
  }, {});
};
prototypeAccessors$3.rules.get = function() {
  return this._base.rules;
};
prototypeAccessors$3.fields.get = function() {
  return new FieldBag(this._base.fields.filter({ vmId: this.id }));
};
prototypeAccessors$3.dictionary.get = function() {
  return this._base.dictionary;
};
prototypeAccessors$3.locale.get = function() {
  return this._base.locale;
};
prototypeAccessors$3.locale.set = function(val) {
  this._base.locale = val;
};
ScopedValidator.prototype.localize = function localize() {
  var ref;
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return (ref = this._base).localize.apply(ref, args);
};
ScopedValidator.prototype.update = function update3() {
  var ref;
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return (ref = this._base).update.apply(ref, args);
};
ScopedValidator.prototype.attach = function attach(opts) {
  var attachOpts = assign({}, opts, { vmId: this.id });
  return this._base.attach(attachOpts);
};
ScopedValidator.prototype.pause = function pause() {
  this._paused = true;
};
ScopedValidator.prototype.resume = function resume() {
  this._paused = false;
};
ScopedValidator.prototype.remove = function remove4(ruleName) {
  return this._base.remove(ruleName);
};
ScopedValidator.prototype.detach = function detach(name, scope) {
  return this._base.detach(name, scope, this.id);
};
ScopedValidator.prototype.extend = function extend() {
  var ref;
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return (ref = this._base).extend.apply(ref, args);
};
ScopedValidator.prototype.validate = function validate(descriptor, value, opts) {
  if (opts === void 0) opts = {};
  if (this._paused) {
    return Promise.resolve(true);
  }
  return this._base.validate(descriptor, value, assign({}, { vmId: this.id }, opts || {}));
};
ScopedValidator.prototype.verify = function verify() {
  var ref;
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return (ref = this._base).verify.apply(ref, args);
};
ScopedValidator.prototype.validateAll = function validateAll(values2, opts) {
  if (opts === void 0) opts = {};
  if (this._paused) {
    return Promise.resolve(true);
  }
  return this._base.validateAll(values2, assign({}, { vmId: this.id }, opts || {}));
};
ScopedValidator.prototype.validateScopes = function validateScopes(opts) {
  if (opts === void 0) opts = {};
  if (this._paused) {
    return Promise.resolve(true);
  }
  return this._base.validateScopes(assign({}, { vmId: this.id }, opts || {}));
};
ScopedValidator.prototype.destroy = function destroy2() {
  delete this.id;
  delete this._base;
};
ScopedValidator.prototype.reset = function reset2(matcher) {
  return this._base.reset(Object.assign({}, matcher || {}, { vmId: this.id }));
};
ScopedValidator.prototype.flag = function flag() {
  var ref;
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return (ref = this._base).flag.apply(ref, args.concat([this.id]));
};
ScopedValidator.prototype._resolveField = function _resolveField() {
  var ref;
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return (ref = this._base)._resolveField.apply(ref, args);
};
Object.defineProperties(ScopedValidator.prototype, prototypeAccessors$3);
var VALIDATOR = null;
var getValidator = function() {
  return VALIDATOR;
};
var setValidator = function(value) {
  VALIDATOR = value;
  return value;
};
var requestsValidator = function(injections) {
  if (isObject(injections) && injections.$validator) {
    return true;
  }
  return false;
};
var mixin = {
  provide: function provide() {
    if (this.$validator && !isBuiltInComponent(this.$vnode)) {
      return {
        $validator: this.$validator
      };
    }
    return {};
  },
  beforeCreate: function beforeCreate() {
    if (isBuiltInComponent(this.$vnode) || this.$options.$__veeInject === false) {
      return;
    }
    if (!this.$parent) {
      setConfig(this.$options.$_veeValidate || {});
    }
    var options2 = resolveConfig(this);
    if (!this.$parent || this.$options.$_veeValidate && /new/.test(this.$options.$_veeValidate.validator)) {
      this.$validator = new ScopedValidator(getValidator(), this);
    }
    var requested = requestsValidator(this.$options.inject);
    if (!this.$validator && options2.inject && !requested) {
      this.$validator = new ScopedValidator(getValidator(), this);
    }
    if (!requested && !this.$validator) {
      return;
    }
    if (!requested && this.$validator) {
      var Vue2 = this.$options._base;
      Vue2.util.defineReactive(this.$validator, "errors", this.$validator.errors);
    }
    if (!this.$options.computed) {
      this.$options.computed = {};
    }
    this.$options.computed[options2.errorBagName || "errors"] = function errorBagGetter() {
      return this.$validator.errors;
    };
    this.$options.computed[options2.fieldsBagName || "fields"] = function fieldBagGetter() {
      return this.$validator.fields.items.reduce(function(acc, field) {
        if (field.scope) {
          if (!acc["$" + field.scope]) {
            acc["$" + field.scope] = {};
          }
          acc["$" + field.scope][field.name] = field.flags;
          return acc;
        }
        acc[field.name] = field.flags;
        return acc;
      }, {});
    };
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$validator && this._uid === this.$validator.id) {
      this.$validator.errors.clear();
    }
  }
};
function findField(el, context) {
  if (!context || !context.$validator) {
    return null;
  }
  return context.$validator.fields.findById(el._veeValidateId);
}
var directive = {
  bind: function bind(el, binding, vnode) {
    var validator = vnode.context.$validator;
    if (!validator) {
      if (true) {
        warn("No validator instance is present on vm, did you forget to inject '$validator'?");
      }
      return;
    }
    var fieldOptions = Resolver.generate(el, binding, vnode);
    validator.attach(fieldOptions);
  },
  inserted: function inserted(el, binding, vnode) {
    var field = findField(el, vnode.context);
    var scope = Resolver.resolveScope(el, binding, vnode);
    if (!field || scope === field.scope) {
      return;
    }
    field.update({ scope });
    field.updated = false;
  },
  update: function update4(el, binding, vnode) {
    var field = findField(el, vnode.context);
    if (!field || field.updated && isEqual(binding.value, binding.oldValue)) {
      return;
    }
    var scope = Resolver.resolveScope(el, binding, vnode);
    var rules = Resolver.resolveRules(el, binding, vnode);
    field.update({
      scope,
      rules
    });
  },
  unbind: function unbind(el, binding, ref) {
    var context = ref.context;
    var field = findField(el, context);
    if (!field) {
      return;
    }
    context.$validator.detach(field);
  }
};
var Validator = function Validator2(validations, options2, pluginContainer) {
  if (options2 === void 0) options2 = { fastExit: true };
  if (pluginContainer === void 0) pluginContainer = null;
  this.errors = new ErrorBag();
  this.fields = new FieldBag();
  this._createFields(validations);
  this.paused = false;
  this.fastExit = !isNullOrUndefined(options2 && options2.fastExit) ? options2.fastExit : true;
  this.$vee = pluginContainer || {
    _vm: {
      $nextTick: function(cb) {
        return isCallable(cb) ? cb() : Promise.resolve();
      },
      $emit: function() {
      },
      $off: function() {
      }
    }
  };
};
var prototypeAccessors$4 = { rules: { configurable: true }, dictionary: { configurable: true }, flags: { configurable: true }, locale: { configurable: true } };
var staticAccessors$1 = { rules: { configurable: true }, dictionary: { configurable: true }, locale: { configurable: true } };
staticAccessors$1.rules.get = function() {
  if (true) {
    warn('this accessor will be deprecated, use `import { rules } from "vee-validate"` instead.');
  }
  return RuleContainer.rules;
};
prototypeAccessors$4.rules.get = function() {
  if (true) {
    warn('this accessor will be deprecated, use `import { rules } from "vee-validate"` instead.');
  }
  return RuleContainer.rules;
};
prototypeAccessors$4.dictionary.get = function() {
  return DictionaryResolver.getDriver();
};
staticAccessors$1.dictionary.get = function() {
  return DictionaryResolver.getDriver();
};
prototypeAccessors$4.flags.get = function() {
  return this.fields.items.reduce(function(acc, field) {
    var obj2;
    if (field.scope) {
      acc["$" + field.scope] = (obj2 = {}, obj2[field.name] = field.flags, obj2);
      return acc;
    }
    acc[field.name] = field.flags;
    return acc;
  }, {});
};
prototypeAccessors$4.locale.get = function() {
  return Validator.locale;
};
prototypeAccessors$4.locale.set = function(value) {
  Validator.locale = value;
};
staticAccessors$1.locale.get = function() {
  return DictionaryResolver.getDriver().locale;
};
staticAccessors$1.locale.set = function(value) {
  var hasChanged = value !== DictionaryResolver.getDriver().locale;
  DictionaryResolver.getDriver().locale = value;
  if (hasChanged && Validator.$vee && Validator.$vee._vm) {
    Validator.$vee._vm.$emit("localeChanged");
  }
};
Validator.create = function create(validations, options2) {
  if (true) {
    warn("Please use `new` to create new validator instances.");
  }
  return new Validator(validations, options2);
};
Validator.extend = function extend2(name, validator, options2) {
  if (options2 === void 0) options2 = {};
  Validator._guardExtend(name, validator);
  var mergedOpts = validator.options || {};
  Validator._merge(name, {
    validator,
    paramNames: options2 && options2.paramNames || validator.paramNames,
    options: assign({ hasTarget: false, immediate: true }, mergedOpts, options2 || {})
  });
};
Validator.remove = function remove5(name) {
  if (true) {
    warn("this method will be deprecated, you can still override your rules with `extend`");
  }
  RuleContainer.remove(name);
};
Validator.prototype.localize = function localize2(lang, dictionary) {
  Validator.localize(lang, dictionary);
};
Validator.localize = function localize3(lang, dictionary) {
  var obj2;
  if (isObject(lang)) {
    DictionaryResolver.getDriver().merge(lang);
    return;
  }
  if (dictionary) {
    var locale2 = lang || dictionary.name;
    dictionary = assign({}, dictionary);
    DictionaryResolver.getDriver().merge((obj2 = {}, obj2[locale2] = dictionary, obj2));
  }
  if (lang) {
    Validator.locale = lang;
  }
};
Validator.prototype.attach = function attach2(fieldOpts) {
  var this$1 = this;
  var oldFieldMatcher = { name: fieldOpts.name, scope: fieldOpts.scope, persist: true };
  var oldField = fieldOpts.persist ? this.fields.find(oldFieldMatcher) : null;
  if (oldField) {
    fieldOpts.flags = oldField.flags;
    oldField.destroy();
    this.fields.remove(oldField);
  }
  var value = fieldOpts.initialValue;
  var field = new Field(fieldOpts);
  this.fields.push(field);
  if (field.immediate) {
    this.$vee._vm.$nextTick(function() {
      return this$1.validate("#" + field.id, value || field.value, { vmId: fieldOpts.vmId });
    });
  } else {
    this._validate(field, value || field.value, { initial: true }).then(function(result) {
      field.flags.valid = result.valid;
      field.flags.invalid = !result.valid;
    });
  }
  return field;
};
Validator.prototype.flag = function flag2(name, flags, uid) {
  if (uid === void 0) uid = null;
  var field = this._resolveField(name, void 0, uid);
  if (!field || !flags) {
    return;
  }
  field.setFlags(flags);
};
Validator.prototype.detach = function detach2(name, scope, uid) {
  var field = isCallable(name.destroy) ? name : this._resolveField(name, scope, uid);
  if (!field) {
    return;
  }
  if (!field.persist) {
    field.destroy();
    this.errors.remove(field.name, field.scope, field.vmId);
    this.fields.remove(field);
  }
};
Validator.prototype.extend = function extend3(name, validator, options2) {
  if (options2 === void 0) options2 = {};
  Validator.extend(name, validator, options2);
};
Validator.prototype.reset = function reset3(matcher) {
  var this$1 = this;
  return this.$vee._vm.$nextTick().then(function() {
    return this$1.$vee._vm.$nextTick();
  }).then(function() {
    this$1.fields.filter(matcher).forEach(function(field) {
      field.waitFor(null);
      field.reset();
      this$1.errors.remove(field.name, field.scope, matcher && matcher.vmId);
    });
  });
};
Validator.prototype.update = function update5(id2, ref) {
  var scope = ref.scope;
  var field = this._resolveField("#" + id2);
  if (!field) {
    return;
  }
  this.errors.update(id2, { scope });
};
Validator.prototype.remove = function remove6(name) {
  Validator.remove(name);
};
Validator.prototype.validate = function validate2(fieldDescriptor, value, ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var silent = ref.silent;
  var vmId = ref.vmId;
  if (this.paused) {
    return Promise.resolve(true);
  }
  if (isNullOrUndefined(fieldDescriptor)) {
    return this.validateScopes({ silent, vmId });
  }
  if (fieldDescriptor === "*") {
    return this.validateAll(void 0, { silent, vmId });
  }
  if (/^(.+)\.\*$/.test(fieldDescriptor)) {
    var matched = fieldDescriptor.match(/^(.+)\.\*$/)[1];
    return this.validateAll(matched);
  }
  var field = this._resolveField(fieldDescriptor);
  if (!field) {
    return this._handleFieldNotFound(fieldDescriptor);
  }
  if (!silent) {
    field.flags.pending = true;
  }
  if (value === void 0) {
    value = field.value;
  }
  var validationPromise = this._validate(field, value);
  field.waitFor(validationPromise);
  return validationPromise.then(function(result) {
    if (!silent && field.isWaitingFor(validationPromise)) {
      field.waitFor(null);
      this$1._handleValidationResults([result], vmId);
    }
    return result.valid;
  });
};
Validator.prototype.pause = function pause2() {
  this.paused = true;
  return this;
};
Validator.prototype.resume = function resume2() {
  this.paused = false;
  return this;
};
Validator.prototype.validateAll = function validateAll2(values2, ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var silent = ref.silent;
  var vmId = ref.vmId;
  if (this.paused) {
    return Promise.resolve(true);
  }
  var matcher = null;
  var providedValues = false;
  if (typeof values2 === "string") {
    matcher = { scope: values2, vmId };
  } else if (isObject(values2)) {
    matcher = Object.keys(values2).map(function(key) {
      return { name: key, vmId, scope: null };
    });
    providedValues = true;
  } else if (Array.isArray(values2)) {
    matcher = values2.map(function(key) {
      return typeof key === "object" ? Object.assign({ vmId }, key) : { name: key, vmId };
    });
  } else {
    matcher = { scope: null, vmId };
  }
  return Promise.all(
    this.fields.filter(matcher).map(function(field) {
      return this$1._validate(field, providedValues ? values2[field.name] : field.value);
    })
  ).then(function(results) {
    if (!silent) {
      this$1._handleValidationResults(results, vmId);
    }
    return results.every(function(t) {
      return t.valid;
    });
  });
};
Validator.prototype.validateScopes = function validateScopes2(ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var silent = ref.silent;
  var vmId = ref.vmId;
  if (this.paused) {
    return Promise.resolve(true);
  }
  return Promise.all(
    this.fields.filter({ vmId }).map(function(field) {
      return this$1._validate(field, field.value);
    })
  ).then(function(results) {
    if (!silent) {
      this$1._handleValidationResults(results, vmId);
    }
    return results.every(function(t) {
      return t.valid;
    });
  });
};
Validator.prototype.verify = function verify2(value, rules, options2) {
  if (options2 === void 0) options2 = {};
  var field = {
    name: options2 && options2.name || "{field}",
    rules: normalizeRules(rules),
    bails: getPath("bails", options2, true),
    forceRequired: false,
    get isRequired() {
      return !!this.rules.required || this.forceRequired;
    }
  };
  var targetRules = Object.keys(field.rules).filter(RuleContainer.isTargetRule);
  if (targetRules.length && options2 && isObject(options2.values)) {
    field.dependencies = targetRules.map(function(rule) {
      var ref = field.rules[rule];
      var targetKey = ref[0];
      return {
        name: rule,
        field: { value: options2.values[targetKey] }
      };
    });
  }
  return this._validate(field, value).then(function(result) {
    var errors = [];
    var ruleMap = {};
    result.errors.forEach(function(e) {
      errors.push(e.msg);
      ruleMap[e.rule] = e.msg;
    });
    return {
      valid: result.valid,
      errors,
      failedRules: ruleMap
    };
  });
};
Validator.prototype.destroy = function destroy3() {
  this.$vee._vm.$off("localeChanged");
};
Validator.prototype._createFields = function _createFields(validations) {
  var this$1 = this;
  if (!validations) {
    return;
  }
  Object.keys(validations).forEach(function(field) {
    var options2 = assign({}, { name: field, rules: validations[field] });
    this$1.attach(options2);
  });
};
Validator.prototype._getDateFormat = function _getDateFormat(validations) {
  var format2 = null;
  if (validations.date_format && Array.isArray(validations.date_format)) {
    format2 = validations.date_format[0];
  }
  return format2 || DictionaryResolver.getDriver().getDateFormat(this.locale);
};
Validator.prototype._formatErrorMessage = function _formatErrorMessage(field, rule, data, targetName) {
  if (data === void 0) data = {};
  if (targetName === void 0) targetName = null;
  var name = this._getFieldDisplayName(field);
  var params = this._getLocalizedParams(rule, targetName);
  return DictionaryResolver.getDriver().getFieldMessage(this.locale, field.name, rule.name, [name, params, data]);
};
Validator.prototype._convertParamObjectToArray = function _convertParamObjectToArray(obj2, ruleName) {
  if (Array.isArray(obj2)) {
    return obj2;
  }
  var paramNames2 = RuleContainer.getParamNames(ruleName);
  if (!paramNames2 || !isObject(obj2)) {
    return obj2;
  }
  return paramNames2.reduce(function(prev, paramName) {
    if (paramName in obj2) {
      prev.push(obj2[paramName]);
    }
    return prev;
  }, []);
};
Validator.prototype._getLocalizedParams = function _getLocalizedParams(rule, targetName) {
  if (targetName === void 0) targetName = null;
  var params = this._convertParamObjectToArray(rule.params, rule.name);
  if (rule.options.hasTarget && params && params[0]) {
    var localizedName = targetName || DictionaryResolver.getDriver().getAttribute(this.locale, params[0], params[0]);
    return [localizedName].concat(params.slice(1));
  }
  return params;
};
Validator.prototype._getFieldDisplayName = function _getFieldDisplayName(field) {
  return field.alias || DictionaryResolver.getDriver().getAttribute(this.locale, field.name, field.name);
};
Validator.prototype._convertParamArrayToObj = function _convertParamArrayToObj(params, ruleName) {
  var paramNames2 = RuleContainer.getParamNames(ruleName);
  if (!paramNames2) {
    return params;
  }
  if (isObject(params)) {
    var hasKeys = paramNames2.some(function(name) {
      return Object.keys(params).indexOf(name) !== -1;
    });
    if (hasKeys) {
      return params;
    }
    params = [params];
  }
  return params.reduce(function(prev, value, idx) {
    prev[paramNames2[idx]] = value;
    return prev;
  }, {});
};
Validator.prototype._test = function _test(field, value, rule) {
  var this$1 = this;
  var validator = RuleContainer.getValidatorMethod(rule.name);
  var params = Array.isArray(rule.params) ? toArray(rule.params) : rule.params;
  if (!params) {
    params = [];
  }
  var targetName = null;
  if (!validator || typeof validator !== "function") {
    return Promise.reject(createError("No such validator '" + rule.name + "' exists."));
  }
  if (rule.options.hasTarget && field.dependencies) {
    var target = find(field.dependencies, function(d) {
      return d.name === rule.name;
    });
    if (target) {
      targetName = target.field.alias;
      params = [target.field.value].concat(params.slice(1));
    }
  } else if (rule.name === "required" && field.rejectsFalse) {
    params = params.length ? params : [true];
  }
  if (rule.options.isDate) {
    var dateFormat = this._getDateFormat(field.rules);
    if (rule.name !== "date_format") {
      params.push(dateFormat);
    }
  }
  var result = validator(value, this._convertParamArrayToObj(params, rule.name));
  if (isCallable(result.then)) {
    return result.then(function(values2) {
      var allValid = true;
      var data = {};
      if (Array.isArray(values2)) {
        allValid = values2.every(function(t) {
          return isObject(t) ? t.valid : t;
        });
      } else {
        allValid = isObject(values2) ? values2.valid : values2;
        data = values2.data;
      }
      return {
        valid: allValid,
        data: result.data,
        errors: allValid ? [] : [this$1._createFieldError(field, rule, data, targetName)]
      };
    });
  }
  if (!isObject(result)) {
    result = { valid: result, data: {} };
  }
  return {
    valid: result.valid,
    data: result.data,
    errors: result.valid ? [] : [this._createFieldError(field, rule, result.data, targetName)]
  };
};
Validator._merge = function _merge(name, ref) {
  var validator = ref.validator;
  var options2 = ref.options;
  var paramNames2 = ref.paramNames;
  var validate6 = isCallable(validator) ? validator : validator.validate;
  if (validator.getMessage) {
    DictionaryResolver.getDriver().setMessage(Validator.locale, name, validator.getMessage);
  }
  RuleContainer.add(name, {
    validate: validate6,
    options: options2,
    paramNames: paramNames2
  });
};
Validator._guardExtend = function _guardExtend(name, validator) {
  if (isCallable(validator)) {
    return;
  }
  if (!isCallable(validator.validate)) {
    throw createError(
      "Extension Error: The validator '" + name + "' must be a function or have a 'validate' method."
    );
  }
};
Validator.prototype._createFieldError = function _createFieldError(field, rule, data, targetName) {
  var this$1 = this;
  return {
    id: field.id,
    vmId: field.vmId,
    field: field.name,
    msg: this._formatErrorMessage(field, rule, data, targetName),
    rule: rule.name,
    scope: field.scope,
    regenerate: function() {
      return this$1._formatErrorMessage(field, rule, data, targetName);
    }
  };
};
Validator.prototype._resolveField = function _resolveField2(name, scope, uid) {
  if (name[0] === "#") {
    return this.fields.findById(name.slice(1));
  }
  if (!isNullOrUndefined(scope)) {
    return this.fields.find({ name, scope, vmId: uid });
  }
  if (includes(name, ".")) {
    var ref = name.split(".");
    var fieldScope = ref[0];
    var fieldName = ref.slice(1);
    var field = this.fields.find({ name: fieldName.join("."), scope: fieldScope, vmId: uid });
    if (field) {
      return field;
    }
  }
  return this.fields.find({ name, scope: null, vmId: uid });
};
Validator.prototype._handleFieldNotFound = function _handleFieldNotFound(name, scope) {
  var fullName = isNullOrUndefined(scope) ? name : (!isNullOrUndefined(scope) ? scope + "." : "") + name;
  return Promise.reject(createError(
    'Validating a non-existent field: "' + fullName + '". Use "attach()" first.'
  ));
};
Validator.prototype._handleValidationResults = function _handleValidationResults(results, vmId) {
  var this$1 = this;
  var matchers = results.map(function(result) {
    return { id: result.id };
  });
  this.errors.removeById(matchers.map(function(m) {
    return m.id;
  }));
  results.forEach(function(result) {
    this$1.errors.remove(result.field, result.scope, vmId);
  });
  var allErrors = results.reduce(function(prev, curr) {
    prev.push.apply(prev, curr.errors);
    return prev;
  }, []);
  this.errors.add(allErrors);
  this.fields.filter(matchers).forEach(function(field) {
    var result = find(results, function(r) {
      return r.id === field.id;
    });
    field.setFlags({
      pending: false,
      valid: result.valid,
      validated: true
    });
  });
};
Validator.prototype._shouldSkip = function _shouldSkip(field, value) {
  if (field.bails === false) {
    return false;
  }
  if (field.isDisabled && getConfig().useConstraintAttrs) {
    return true;
  }
  return !field.isRequired && (isNullOrUndefined(value) || value === "" || isEmptyArray(value));
};
Validator.prototype._shouldBail = function _shouldBail(field) {
  if (field.bails !== void 0) {
    return field.bails;
  }
  return this.fastExit;
};
Validator.prototype._validate = function _validate(field, value, ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var initial = ref.initial;
  var requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);
  field.forceRequired = false;
  requireRules.forEach(function(rule) {
    var ruleOptions = RuleContainer.getOptions(rule);
    var result = this$1._test(field, value, { name: rule, params: field.rules[rule], options: ruleOptions });
    if (isCallable(result.then)) {
      throw createError("Require rules cannot be async");
    }
    if (!isObject(result)) {
      throw createError("Require rules has to return an object (see docs)");
    }
    if (result.data.required === true) {
      field.forceRequired = true;
    }
  });
  if (this._shouldSkip(field, value)) {
    return Promise.resolve({ valid: true, id: field.id, field: field.name, scope: field.scope, errors: [] });
  }
  var promises = [];
  var errors = [];
  var isExitEarly = false;
  if (isCallable(field.checkValueChanged)) {
    field.flags.changed = field.checkValueChanged();
  }
  Object.keys(field.rules).filter(function(rule) {
    if (!initial || !RuleContainer.has(rule)) {
      return true;
    }
    return RuleContainer.isImmediate(rule);
  }).some(function(rule) {
    var ruleOptions = RuleContainer.getOptions(rule);
    var result = this$1._test(field, value, { name: rule, params: field.rules[rule], options: ruleOptions });
    if (isCallable(result.then)) {
      promises.push(result);
    } else if (!result.valid && this$1._shouldBail(field)) {
      errors.push.apply(errors, result.errors);
      isExitEarly = true;
    } else {
      promises.push(new Promise(function(resolve) {
        return resolve(result);
      }));
    }
    return isExitEarly;
  });
  if (isExitEarly) {
    return Promise.resolve({ valid: false, errors, id: field.id, field: field.name, scope: field.scope });
  }
  return Promise.all(promises).then(function(results) {
    return results.reduce(function(prev, v) {
      var ref2;
      if (!v.valid) {
        (ref2 = prev.errors).push.apply(ref2, v.errors);
      }
      prev.valid = prev.valid && v.valid;
      return prev;
    }, { valid: true, errors, id: field.id, field: field.name, scope: field.scope });
  });
};
Object.defineProperties(Validator.prototype, prototypeAccessors$4);
Object.defineProperties(Validator, staticAccessors$1);
var normalizeValue = function(value) {
  if (isObject(value)) {
    return Object.keys(value).reduce(function(prev, key) {
      prev[key] = normalizeValue(value[key]);
      return prev;
    }, {});
  }
  if (isCallable(value)) {
    return value("{0}", ["{1}", "{2}", "{3}"]);
  }
  return value;
};
var normalizeFormat = function(locale2) {
  var dictionary = {};
  if (locale2.messages) {
    dictionary.messages = normalizeValue(locale2.messages);
  }
  if (locale2.custom) {
    dictionary.custom = normalizeValue(locale2.custom);
  }
  if (locale2.attributes) {
    dictionary.attributes = locale2.attributes;
  }
  if (!isNullOrUndefined(locale2.dateFormat)) {
    dictionary.dateFormat = locale2.dateFormat;
  }
  return dictionary;
};
var I18nDictionary = function I18nDictionary2(i18n, rootKey) {
  this.i18n = i18n;
  this.rootKey = rootKey;
};
var prototypeAccessors$5 = { locale: { configurable: true } };
prototypeAccessors$5.locale.get = function() {
  return this.i18n.locale;
};
prototypeAccessors$5.locale.set = function(value) {
  warn("Cannot set locale from the validator when using vue-i18n, use i18n.locale setter instead");
};
I18nDictionary.prototype.getDateFormat = function getDateFormat2(locale2) {
  return this.i18n.getDateTimeFormat(locale2 || this.locale);
};
I18nDictionary.prototype.setDateFormat = function setDateFormat2(locale2, value) {
  this.i18n.setDateTimeFormat(locale2 || this.locale, value);
};
I18nDictionary.prototype.getMessage = function getMessage2(_, key, data) {
  var path = this.rootKey + ".messages." + key;
  var dataOptions = data;
  if (Array.isArray(data)) {
    dataOptions = [].concat.apply([], data);
  }
  if (this.i18n.te(path)) {
    return this.i18n.t(path, dataOptions);
  }
  if (this.i18n.te(path, this.i18n.fallbackLocale)) {
    return this.i18n.t(path, this.i18n.fallbackLocale, dataOptions);
  }
  return this.i18n.t(this.rootKey + ".messages._default", dataOptions);
};
I18nDictionary.prototype.getAttribute = function getAttribute2(_, key, fallback) {
  if (fallback === void 0) fallback = "";
  var path = this.rootKey + ".attributes." + key;
  if (this.i18n.te(path)) {
    return this.i18n.t(path);
  }
  return fallback;
};
I18nDictionary.prototype.getFieldMessage = function getFieldMessage2(_, field, key, data) {
  var path = this.rootKey + ".custom." + field + "." + key;
  if (this.i18n.te(path)) {
    return this.i18n.t(path, data);
  }
  return this.getMessage(_, key, data);
};
I18nDictionary.prototype.merge = function merge$12(dictionary) {
  var this$1 = this;
  Object.keys(dictionary).forEach(function(localeKey) {
    var obj2;
    var clone = merge({}, getPath(localeKey + "." + this$1.rootKey, this$1.i18n.messages, {}));
    var locale2 = merge(clone, normalizeFormat(dictionary[localeKey]));
    this$1.i18n.mergeLocaleMessage(localeKey, (obj2 = {}, obj2[this$1.rootKey] = locale2, obj2));
    if (locale2.dateFormat) {
      this$1.i18n.setDateTimeFormat(localeKey, locale2.dateFormat);
    }
  });
};
I18nDictionary.prototype.setMessage = function setMessage2(locale2, key, value) {
  var obj2, obj$1;
  this.merge((obj$1 = {}, obj$1[locale2] = {
    messages: (obj2 = {}, obj2[key] = value, obj2)
  }, obj$1));
};
I18nDictionary.prototype.setAttribute = function setAttribute2(locale2, key, value) {
  var obj2, obj$1;
  this.merge((obj$1 = {}, obj$1[locale2] = {
    attributes: (obj2 = {}, obj2[key] = value, obj2)
  }, obj$1));
};
Object.defineProperties(I18nDictionary.prototype, prototypeAccessors$5);
var aggressive = function() {
  return {
    on: ["input"]
  };
};
var lazy = function() {
  return {
    on: ["change"]
  };
};
var eager = function(ref) {
  var errors = ref.errors;
  if (errors.length) {
    return {
      on: ["input"]
    };
  }
  return {
    on: ["change", "blur"]
  };
};
var passive = function() {
  return {
    on: []
  };
};
var modes = {
  aggressive,
  eager,
  passive,
  lazy
};
var Vue;
var pendingPlugins;
var pluginInstance;
var VeeValidate$1 = function VeeValidate2(config, _Vue) {
  this.configure(config);
  pluginInstance = this;
  if (_Vue) {
    Vue = _Vue;
  }
  this._validator = setValidator(
    new Validator(null, { fastExit: config && config.fastExit }, this)
  );
  this._initVM(this.config);
  this._initI18n(this.config);
};
var prototypeAccessors$6 = { i18nDriver: { configurable: true }, config: { configurable: true } };
var staticAccessors$2 = { i18nDriver: { configurable: true }, config: { configurable: true } };
VeeValidate$1.setI18nDriver = function setI18nDriver(driver, instance) {
  DictionaryResolver.setDriver(driver, instance);
};
VeeValidate$1.configure = function configure(cfg) {
  setConfig(cfg);
};
VeeValidate$1.setMode = function setMode(mode, implementation) {
  setConfig({ mode });
  if (!implementation) {
    return;
  }
  if (!isCallable(implementation)) {
    throw new Error("A mode implementation must be a function");
  }
  modes[mode] = implementation;
};
VeeValidate$1.use = function use(plugin, options2) {
  if (options2 === void 0) options2 = {};
  if (!isCallable(plugin)) {
    return warn("The plugin must be a callable function");
  }
  if (!pluginInstance) {
    if (!pendingPlugins) {
      pendingPlugins = [];
    }
    pendingPlugins.push({ plugin, options: options2 });
    return;
  }
  plugin({ Validator, ErrorBag, Rules: Validator.rules }, options2);
};
VeeValidate$1.install = function install(_Vue, opts) {
  if (Vue && _Vue === Vue) {
    if (true) {
      warn("already installed, Vue.use(VeeValidate) should only be called once.");
    }
    return;
  }
  Vue = _Vue;
  pluginInstance = new VeeValidate$1(opts);
  Validator.$vee = pluginInstance;
  detectPassiveSupport();
  Vue.mixin(mixin);
  Vue.directive("validate", directive);
  if (pendingPlugins) {
    pendingPlugins.forEach(function(ref) {
      var plugin = ref.plugin;
      var options2 = ref.options;
      VeeValidate$1.use(plugin, options2);
    });
    pendingPlugins = null;
  }
};
prototypeAccessors$6.i18nDriver.get = function() {
  return DictionaryResolver.getDriver();
};
staticAccessors$2.i18nDriver.get = function() {
  return DictionaryResolver.getDriver();
};
prototypeAccessors$6.config.get = function() {
  return getConfig();
};
staticAccessors$2.config.get = function() {
  return getConfig();
};
VeeValidate$1.prototype._initVM = function _initVM(config) {
  var this$1 = this;
  this._vm = new Vue({
    data: function() {
      return {
        errors: this$1._validator.errors,
        fields: this$1._validator.fields
      };
    }
  });
};
VeeValidate$1.prototype._initI18n = function _initI18n(config) {
  var this$1 = this;
  var dictionary = config.dictionary;
  var i18n = config.i18n;
  var i18nRootKey = config.i18nRootKey;
  var locale2 = config.locale;
  var onLocaleChanged = function() {
    if (dictionary) {
      this$1.i18nDriver.merge(dictionary);
    }
    this$1._validator.errors.regenerate();
  };
  if (i18n) {
    VeeValidate$1.setI18nDriver("i18n", new I18nDictionary(i18n, i18nRootKey));
    i18n._vm.$watch("locale", onLocaleChanged);
  } else if (typeof window !== "undefined") {
    this._vm.$on("localeChanged", onLocaleChanged);
  }
  if (dictionary) {
    this.i18nDriver.merge(dictionary);
  }
  if (locale2 && !i18n) {
    this._validator.localize(locale2);
  }
};
VeeValidate$1.prototype.configure = function configure2(cfg) {
  setConfig(cfg);
};
Object.defineProperties(VeeValidate$1.prototype, prototypeAccessors$6);
Object.defineProperties(VeeValidate$1, staticAccessors$2);
VeeValidate$1.mixin = mixin;
VeeValidate$1.directive = directive;
VeeValidate$1.Validator = Validator;
VeeValidate$1.ErrorBag = ErrorBag;
var formatFileSize = function(size2) {
  var units = ["Byte", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  var threshold = 1024;
  size2 = Number(size2) * threshold;
  var i = size2 === 0 ? 0 : Math.floor(Math.log(size2) / Math.log(threshold));
  return (size2 / Math.pow(threshold, i)).toFixed(2) * 1 + " " + units[i];
};
var isDefinedGlobally = function() {
  return typeof VeeValidate !== "undefined";
};
var obj;
var messages = {
  _default: function(field) {
    return "The " + field + " value is not valid";
  },
  after: function(field, ref) {
    var target = ref[0];
    var inclusion = ref[1];
    return "The " + field + " must be after " + (inclusion ? "or equal to " : "") + target;
  },
  alpha: function(field) {
    return "The " + field + " field may only contain alphabetic characters";
  },
  alpha_dash: function(field) {
    return "The " + field + " field may contain alpha-numeric characters as well as dashes and underscores";
  },
  alpha_num: function(field) {
    return "The " + field + " field may only contain alpha-numeric characters";
  },
  alpha_spaces: function(field) {
    return "The " + field + " field may only contain alphabetic characters as well as spaces";
  },
  before: function(field, ref) {
    var target = ref[0];
    var inclusion = ref[1];
    return "The " + field + " must be before " + (inclusion ? "or equal to " : "") + target;
  },
  between: function(field, ref) {
    var min2 = ref[0];
    var max2 = ref[1];
    return "The " + field + " field must be between " + min2 + " and " + max2;
  },
  confirmed: function(field) {
    return "The " + field + " confirmation does not match";
  },
  credit_card: function(field) {
    return "The " + field + " field is invalid";
  },
  date_between: function(field, ref) {
    var min2 = ref[0];
    var max2 = ref[1];
    return "The " + field + " must be between " + min2 + " and " + max2;
  },
  date_format: function(field, ref) {
    var format2 = ref[0];
    return "The " + field + " must be in the format " + format2;
  },
  decimal: function(field, ref) {
    if (ref === void 0) ref = [];
    var decimals = ref[0];
    if (decimals === void 0) decimals = "*";
    return "The " + field + " field must be numeric and may contain" + (!decimals || decimals === "*" ? "" : " " + decimals) + " decimal points";
  },
  digits: function(field, ref) {
    var length2 = ref[0];
    return "The " + field + " field must be numeric and contains exactly " + length2 + " digits";
  },
  dimensions: function(field, ref) {
    var width = ref[0];
    var height = ref[1];
    return "The " + field + " field must be " + width + " pixels by " + height + " pixels";
  },
  email: function(field) {
    return "The " + field + " field must be a valid email";
  },
  excluded: function(field) {
    return "The " + field + " field must be a valid value";
  },
  ext: function(field) {
    return "The " + field + " field must be a valid file";
  },
  image: function(field) {
    return "The " + field + " field must be an image";
  },
  included: function(field) {
    return "The " + field + " field must be a valid value";
  },
  integer: function(field) {
    return "The " + field + " field must be an integer";
  },
  ip: function(field) {
    return "The " + field + " field must be a valid ip address";
  },
  ip_or_fqdn: function(field) {
    return "The " + field + " field must be a valid ip address or FQDN";
  },
  length: function(field, ref) {
    var length2 = ref[0];
    var max2 = ref[1];
    if (max2) {
      return "The " + field + " length must be between " + length2 + " and " + max2;
    }
    return "The " + field + " length must be " + length2;
  },
  max: function(field, ref) {
    var length2 = ref[0];
    return "The " + field + " field may not be greater than " + length2 + " characters";
  },
  max_value: function(field, ref) {
    var max2 = ref[0];
    return "The " + field + " field must be " + max2 + " or less";
  },
  mimes: function(field) {
    return "The " + field + " field must have a valid file type";
  },
  min: function(field, ref) {
    var length2 = ref[0];
    return "The " + field + " field must be at least " + length2 + " characters";
  },
  min_value: function(field, ref) {
    var min2 = ref[0];
    return "The " + field + " field must be " + min2 + " or more";
  },
  numeric: function(field) {
    return "The " + field + " field may only contain numeric characters";
  },
  regex: function(field) {
    return "The " + field + " field format is invalid";
  },
  required: function(field) {
    return "The " + field + " field is required";
  },
  required_if: function(field, ref) {
    var target = ref[0];
    return "The " + field + " field is required when the " + target + " field has this value";
  },
  size: function(field, ref) {
    var size2 = ref[0];
    return "The " + field + " size must be less than " + formatFileSize(size2);
  },
  url: function(field) {
    return "The " + field + " field is not a valid URL";
  }
};
var locale = {
  name: "en",
  messages,
  attributes: {}
};
if (isDefinedGlobally()) {
  VeeValidate.Validator.localize((obj = {}, obj[locale.name] = locale, obj));
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
var MILLISECONDS_IN_MINUTE = 6e4;
function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = date.getTimezoneOffset();
  date.setSeconds(0, 0);
  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
}
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE$1 = 6e4;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns = {
  dateTimeDelimeter: /[T ]/,
  plainTime: /:/,
  timeZoneDelimeter: /[Z ]/i,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // timezone tokens
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-])(\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function toDate(argument, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  if (argument === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var options2 = dirtyOptions || {};
  var additionalDigits = options2.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options2.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date = parseDate(restDateString, year);
  if (isNaN(date)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
    }
    return new Date(timestamp + time + offset);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimeter);
  var timeString;
  if (patterns.plainTime.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimeter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var patternYYY = patterns.YYY[additionalDigits];
  var patternYYYYY = patterns.YYYYY[additionalDigits];
  var token;
  token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  }
  token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null) {
    return null;
  }
  var token;
  var date;
  var month;
  var week;
  if (dateString.length === 0) {
    date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(year);
    return date;
  }
  token = patterns.MM.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    if (!validateDate(year, month)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month);
    return date;
  }
  token = patterns.DDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    if (!validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  }
  token = patterns.MMDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    if (!validateDate(year, month, day)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, day);
    return date;
  }
  token = patterns.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    if (!validateWeekDate(year, week)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week);
  }
  token = patterns.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  var token;
  var hours;
  var minutes;
  token = patterns.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(",", "."));
    if (!validateTime(hours)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR;
  }
  token = patterns.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(",", "."));
    if (!validateTime(hours, minutes)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1;
  }
  token = patterns.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(",", "."));
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1 + seconds * 1e3;
  }
  return null;
}
function parseTimezone(timezoneString) {
  var token;
  var absoluteOffset;
  token = patterns.timezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }
  var hours;
  token = patterns.timezoneHH.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    if (!validateTimezone()) {
      return NaN;
    }
    absoluteOffset = hours * MILLISECONDS_IN_HOUR;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  token = patterns.timezoneHHMM.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    var minutes = parseInt(token[3], 10);
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  return 0;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  if (month < 0 || month > 11) {
    return false;
  }
  if (date != null) {
    if (date < 1) {
      return false;
    }
    var isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
      return false;
    }
    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  var isLeapYear = isLeapYearIndex(year);
  if (isLeapYear && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(year, week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours, minutes, seconds) {
  if (hours != null && (hours < 0 || hours >= 25)) {
    return false;
  }
  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}
function validateTimezone(hours, minutes) {
  if (minutes != null && (minutes < 0 || minutes > 59)) {
    return false;
  }
  return true;
}
function addMilliseconds(dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var timestamp = toDate(dirtyDate, dirtyOptions).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function isValid(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  return !isNaN(date);
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
function formatDistance(token, count2, options2) {
  options2 = options2 || {};
  var result;
  if (typeof formatDistanceLocale[token] === "string") {
    result = formatDistanceLocale[token];
  } else if (count2 === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace("{{count}}", count2);
  }
  if (options2.addSuffix) {
    if (options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
}
function buildFormatLongFn(args) {
  return function(dirtyOptions) {
    var options2 = dirtyOptions || {};
    var width = options2.width ? String(options2.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
function formatRelative(token, date, baseDate, options2) {
  return formatRelativeLocale[token];
}
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options2 = dirtyOptions || {};
    var width = options2.width ? String(options2.width) : args.defaultWidth;
    var context = options2.context ? String(options2.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      valuesArray = args.formattingValues[width] || args.formattingValues[args.defaultFormattingWidth];
    } else {
      valuesArray = args.values[width] || args.values[args.defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
function ordinalNumber(dirtyNumber, dirtyOptions) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
}
var localize4 = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaulFormattingWidth: "wide"
  })
};
function buildMatchPatternFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options2 = dirtyOptions || {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) {
      return null;
    }
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    return {
      value,
      rest: string.slice(matchedString.length)
    };
  };
}
function buildMatchFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options2 = dirtyOptions || {};
    var width = options2.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var value;
    if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
      value = parsePatterns.findIndex(function(pattern) {
        return pattern.test(string);
      });
    } else {
      value = findKey(parsePatterns, function(pattern) {
        return pattern.test(string);
      });
    }
    value = args.valueCallback ? args.valueCallback(value) : value;
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    return {
      value,
      rest: string.slice(matchedString.length)
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var locale$1 = {
  formatDistance,
  formatLong,
  formatRelative,
  localize: localize4,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate, dirtyOptions);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear, dirtyOptions);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var year = getUTCISOWeekYear(dirtyDate, dirtyOptions);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary, dirtyOptions);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var diff = startOfUTCISOWeek(date, dirtyOptions).getTime() - startOfUTCISOWeekYear(date, dirtyOptions).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate, options2);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var year = date.getUTCFullYear();
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCWeek(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var diff = startOfUTCWeek(date, dirtyOptions).getTime() - startOfUTCWeekYear(date, dirtyOptions).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token, localize5) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize5.era(era, { width: "abbreviated" });
      case "GGGGG":
        return localize5.era(era, { width: "narrow" });
      case "GGGG":
      default:
        return localize5.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize5, options2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    if (token === "yy") {
      var twoDigitYear = year % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "yo") {
      return localize5.ordinalNumber(year, { unit: "year" });
    }
    return addLeadingZeros(year, token.length);
  },
  // Local week-numbering year
  Y: function(date, token, localize5, options2) {
    var signedWeekYear = getUTCWeekYear(date, options2);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize5.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token, localize5, options2) {
    var isoWeekYear = getUTCISOWeekYear(date, options2);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token, localize5, options2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize5, options2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize5.ordinalNumber(quarter, { unit: "quarter" });
      case "QQQ":
        return localize5.quarter(quarter, { width: "abbreviated", context: "formatting" });
      case "QQQQQ":
        return localize5.quarter(quarter, { width: "narrow", context: "formatting" });
      case "QQQQ":
      default:
        return localize5.quarter(quarter, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize5, options2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize5.ordinalNumber(quarter, { unit: "quarter" });
      case "qqq":
        return localize5.quarter(quarter, { width: "abbreviated", context: "standalone" });
      case "qqqqq":
        return localize5.quarter(quarter, { width: "narrow", context: "standalone" });
      case "qqqq":
      default:
        return localize5.quarter(quarter, { width: "wide", context: "standalone" });
    }
  },
  // Month
  M: function(date, token, localize5, options2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
        return String(month + 1);
      case "MM":
        return addLeadingZeros(month + 1, 2);
      case "Mo":
        return localize5.ordinalNumber(month + 1, { unit: "month" });
      case "MMM":
        return localize5.month(month, { width: "abbreviated", context: "formatting" });
      case "MMMMM":
        return localize5.month(month, { width: "narrow", context: "formatting" });
      case "MMMM":
      default:
        return localize5.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize5, options2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize5.ordinalNumber(month + 1, { unit: "month" });
      case "LLL":
        return localize5.month(month, { width: "abbreviated", context: "standalone" });
      case "LLLLL":
        return localize5.month(month, { width: "narrow", context: "standalone" });
      case "LLLL":
      default:
        return localize5.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize5, options2) {
    var week = getUTCWeek(date, options2);
    if (token === "wo") {
      return localize5.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize5, options2) {
    var isoWeek = getUTCISOWeek(date, options2);
    if (token === "Io") {
      return localize5.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize5, options2) {
    var dayOfMonth = date.getUTCDate();
    if (token === "do") {
      return localize5.ordinalNumber(dayOfMonth, { unit: "date" });
    }
    return addLeadingZeros(dayOfMonth, token.length);
  },
  // Day of year
  D: function(date, token, localize5, options2) {
    var dayOfYear = getUTCDayOfYear(date, options2);
    if (token === "Do") {
      return localize5.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize5, options2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize5.day(dayOfWeek, { width: "abbreviated", context: "formatting" });
      case "EEEEE":
        return localize5.day(dayOfWeek, { width: "narrow", context: "formatting" });
      case "EEEEEE":
        return localize5.day(dayOfWeek, { width: "short", context: "formatting" });
      case "EEEE":
      default:
        return localize5.day(dayOfWeek, { width: "wide", context: "formatting" });
    }
  },
  // Local day of week
  e: function(date, token, localize5, options2) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize5.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize5.day(dayOfWeek, { width: "abbreviated", context: "formatting" });
      case "eeeee":
        return localize5.day(dayOfWeek, { width: "narrow", context: "formatting" });
      case "eeeeee":
        return localize5.day(dayOfWeek, { width: "short", context: "formatting" });
      case "eeee":
      default:
        return localize5.day(dayOfWeek, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize5, options2) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize5.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize5.day(dayOfWeek, { width: "abbreviated", context: "standalone" });
      case "ccccc":
        return localize5.day(dayOfWeek, { width: "narrow", context: "standalone" });
      case "cccccc":
        return localize5.day(dayOfWeek, { width: "short", context: "standalone" });
      case "cccc":
      default:
        return localize5.day(dayOfWeek, { width: "wide", context: "standalone" });
    }
  },
  // ISO day of week
  i: function(date, token, localize5, options2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize5.ordinalNumber(isoDayOfWeek, { unit: "day" });
      case "iii":
        return localize5.day(dayOfWeek, { width: "abbreviated", context: "formatting" });
      case "iiiii":
        return localize5.day(dayOfWeek, { width: "narrow", context: "formatting" });
      case "iiiiii":
        return localize5.day(dayOfWeek, { width: "short", context: "formatting" });
      case "iiii":
      default:
        return localize5.day(dayOfWeek, { width: "wide", context: "formatting" });
    }
  },
  // AM or PM
  a: function(date, token, localize5) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" });
      case "aaaaa":
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "narrow", context: "formatting" });
      case "aaaa":
      default:
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "wide", context: "formatting" });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize5) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" });
      case "bbbbb":
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "narrow", context: "formatting" });
      case "bbbb":
      default:
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "wide", context: "formatting" });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize5) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "abbreviated", context: "formatting" });
      case "BBBBB":
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "narrow", context: "formatting" });
      case "BBBB":
      default:
        return localize5.dayPeriod(dayPeriodEnumValue, { width: "wide", context: "formatting" });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize5, options2) {
    var hours = date.getUTCHours() % 12;
    if (hours === 0) {
      hours = 12;
    }
    if (token === "ho") {
      return localize5.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [0-23]
  H: function(date, token, localize5, options2) {
    var hours = date.getUTCHours();
    if (token === "Ho") {
      return localize5.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [0-11]
  K: function(date, token, localize5, options2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize5.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize5, options2) {
    var hours = date.getUTCHours();
    if (hours === 0) {
      hours = 24;
    }
    if (token === "ko") {
      return localize5.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize5, options2) {
    var minutes = date.getUTCMinutes();
    if (token === "mo") {
      return localize5.ordinalNumber(minutes, { unit: "minute" });
    }
    return addLeadingZeros(minutes, token.length);
  },
  // Second
  s: function(date, token, localize5, options2) {
    var seconds = date.getUTCSeconds();
    if (token === "so") {
      return localize5.ordinalNumber(seconds, { unit: "second" });
    }
    return addLeadingZeros(seconds, token.length);
  },
  // Fraction of second
  S: function(date, token, localize5, options2) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, numberOfDigits);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, localize5, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, localize5, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, localize5, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, localize5, options2) {
    var originalDate = options2._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, localize5, options2) {
    var originalDate = options2._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, localize5, options2) {
    var originalDate = options2._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
function formatTimezone(offset, dirtyDelimeter) {
  var delimeter = dirtyDelimeter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimeter + minutes;
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimeter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimeter);
}
function formatTimezoneShort(offset, dirtyDelimeter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimeter = dirtyDelimeter || "";
  return sign + String(hours) + delimeter + addLeadingZeros(minutes, 2);
}
function dateLongFormatter(pattern, formatLong2, options2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
}
function timeLongFormatter(pattern, formatLong2, options2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
}
function dateTimeLongFormatter(pattern, formatLong2, options2) {
  var matchResult = pattern.match(/(P+)(p+)?/);
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
function subMilliseconds(dirtyDate, dirtyAmount, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount, dirtyOptions);
}
var protectedTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedToken(token) {
  return protectedTokens.indexOf(token) !== -1;
}
function throwProtectedError(token) {
  throw new RangeError(
    "`options.awareOfUnicodeTokens` must be set to `true` to use `" + token + "` token; see: https://git.io/fxCyr"
  );
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'(.*?)'?$/;
var doubleQuoteRegExp = /''/g;
function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError(
      "2 arguments required, but only " + arguments.length + " present"
    );
  }
  var formatStr = String(dirtyFormatStr);
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale || locale$1;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError(
      "firstWeekContainsDate must be between 1 and 7 inclusively"
    );
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate, options2);
  if (!isValid(originalDate, options2)) {
    return "Invalid Date";
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset, options2);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters[firstCharacter];
    if (formatter) {
      if (!options2.awareOfUnicodeTokens && isProtectedToken(substring)) {
        throwProtectedError(substring);
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function isAfter(dirtyDate, dirtyDateToCompare, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var dateToCompare = toDate(dirtyDateToCompare, dirtyOptions);
  return date.getTime() < dateToCompare.getTime();
}
function isEqual$1(dirtyLeftDate, dirtyRightDate, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyLeftDate, dirtyOptions);
  var dateRight = toDate(dirtyRightDate, dirtyOptions);
  return dateLeft.getTime() === dateRight.getTime();
}
function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function setUTCWeek(dirtyDate, dirtyWeek, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, dirtyOptions) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function setUTCISODay(dirtyDate, dirtyDay, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate, dirtyOptions);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function setUTCISOWeek(dirtyDate, dirtyISOWeek, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date = toDate(dirtyDate, dirtyOptions);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date, dirtyOptions) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var MILLISECONDS_IN_HOUR$1 = 36e5;
var MILLISECONDS_IN_MINUTE$2 = 6e4;
var MILLISECONDS_IN_SECOND = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2 + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}
function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), string, valueCallback);
  }
}
function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), string, valueCallback);
  }
}
function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
var DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var parsers = {
  // Era
  G: {
    priority: 140,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(string, { width: "abbreviated" }) || match2.era(string, { width: "narrow" });
        case "GGGGG":
          return match2.era(string, { width: "narrow" });
        case "GGGG":
        default:
          return match2.era(string, { width: "wide" }) || match2.era(string, { width: "abbreviated" }) || match2.era(string, { width: "narrow" });
      }
    },
    set: function(date, value, options2) {
      date.setUTCFullYear(value === 1 ? 10 : -9, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Year
  y: {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    priority: 130,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return parseNDigits(4, string, valueCallback);
        case "yo":
          return match2.ordinalNumber(string, { unit: "year", valueCallback });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function(date, value, options2) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, value, options2) {
      var currentYear = getUTCWeekYear(date, options2);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = currentYear > 0 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Local week-numbering year
  Y: {
    priority: 130,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return parseNDigits(4, string, valueCallback);
        case "Yo":
          return match2.ordinalNumber(string, { unit: "year", valueCallback });
        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function(date, value, options2) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function(date, value, options2) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options2.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options2);
      }
      var year = currentYear > 0 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options2.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options2);
    }
  },
  // ISO week-numbering year
  R: {
    priority: 130,
    parse: function(string, token, match2, options2) {
      if (token === "R") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function(date, value, options2) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  },
  // Extended year
  u: {
    priority: 130,
    parse: function(string, token, match2, options2) {
      if (token === "u") {
        return parseNDigitsSigned(4, string);
      }
      return parseNDigitsSigned(token.length, string);
    },
    set: function(date, value, options2) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Quarter
  Q: {
    priority: 120,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, string);
        case "Qo":
          return match2.ordinalNumber(string, { unit: "quarter" });
        case "QQQ":
          return match2.quarter(string, { width: "abbreviated", context: "formatting" }) || match2.quarter(string, { width: "narrow", context: "formatting" });
        case "QQQQQ":
          return match2.quarter(string, { width: "narrow", context: "formatting" });
        case "QQQQ":
        default:
          return match2.quarter(string, { width: "wide", context: "formatting" }) || match2.quarter(string, { width: "abbreviated", context: "formatting" }) || match2.quarter(string, { width: "narrow", context: "formatting" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 4;
    },
    set: function(date, value, options2) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Stand-alone quarter
  q: {
    priority: 120,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, string);
        case "qo":
          return match2.ordinalNumber(string, { unit: "quarter" });
        case "qqq":
          return match2.quarter(string, { width: "abbreviated", context: "standalone" }) || match2.quarter(string, { width: "narrow", context: "standalone" });
        case "qqqqq":
          return match2.quarter(string, { width: "narrow", context: "standalone" });
        case "qqqq":
        default:
          return match2.quarter(string, { width: "wide", context: "standalone" }) || match2.quarter(string, { width: "abbreviated", context: "standalone" }) || match2.quarter(string, { width: "narrow", context: "standalone" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 4;
    },
    set: function(date, value, options2) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Month
  M: {
    priority: 110,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "MM":
          return parseNDigits(2, string, valueCallback);
        case "Mo":
          return match2.ordinalNumber(string, { unit: "month", valueCallback });
        case "MMM":
          return match2.month(string, { width: "abbreviated", context: "formatting" }) || match2.month(string, { width: "narrow", context: "formatting" });
        case "MMMMM":
          return match2.month(string, { width: "narrow", context: "formatting" });
        case "MMMM":
        default:
          return match2.month(string, { width: "wide", context: "formatting" }) || match2.month(string, { width: "abbreviated", context: "formatting" }) || match2.month(string, { width: "narrow", context: "formatting" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 11;
    },
    set: function(date, value, options2) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Stand-alone month
  L: {
    priority: 110,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        case "LL":
          return parseNDigits(2, string, valueCallback);
        case "Lo":
          return match2.ordinalNumber(string, { unit: "month", valueCallback });
        case "LLL":
          return match2.month(string, { width: "abbreviated", context: "standalone" }) || match2.month(string, { width: "narrow", context: "standalone" });
        case "LLLLL":
          return match2.month(string, { width: "narrow", context: "standalone" });
        case "LLLL":
        default:
          return match2.month(string, { width: "wide", context: "standalone" }) || match2.month(string, { width: "abbreviated", context: "standalone" }) || match2.month(string, { width: "narrow", context: "standalone" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 11;
    },
    set: function(date, value, options2) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Local week of year
  w: {
    priority: 100,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, string);
        case "wo":
          return match2.ordinalNumber(string, { unit: "week" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 53;
    },
    set: function(date, value, options2) {
      return startOfUTCWeek(setUTCWeek(date, value, options2), options2);
    }
  },
  // ISO week of year
  I: {
    priority: 100,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, string);
        case "Io":
          return match2.ordinalNumber(string, { unit: "week" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 53;
    },
    set: function(date, value, options2) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options2), options2);
    }
  },
  // Day of the month
  d: {
    priority: 90,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, string);
        case "do":
          return match2.ordinalNumber(string, { unit: "date" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH$1[month];
      }
    },
    set: function(date, value, options2) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Day of year
  D: {
    priority: 90,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, string);
        case "Do":
          return match2.ordinalNumber(string, { unit: "date" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function(date, value, options2) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Day of week
  E: {
    priority: 90,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(string, { width: "abbreviated", context: "formatting" }) || match2.day(string, { width: "short", context: "formatting" }) || match2.day(string, { width: "narrow", context: "formatting" });
        case "EEEEE":
          return match2.day(string, { width: "narrow", context: "formatting" });
        case "EEEEEE":
          return match2.day(string, { width: "short", context: "formatting" }) || match2.day(string, { width: "narrow", context: "formatting" });
        case "EEEE":
        default:
          return match2.day(string, { width: "wide", context: "formatting" }) || match2.day(string, { width: "abbreviated", context: "formatting" }) || match2.day(string, { width: "short", context: "formatting" }) || match2.day(string, { width: "narrow", context: "formatting" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 6;
    },
    set: function(date, value, options2) {
      date = setUTCDay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Local day of week
  e: {
    priority: 90,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return parseNDigits(token.length, string, valueCallback);
        case "eo":
          return match2.ordinalNumber(string, { unit: "day", valueCallback });
        case "eee":
          return match2.day(string, { width: "abbreviated", context: "formatting" }) || match2.day(string, { width: "short", context: "formatting" }) || match2.day(string, { width: "narrow", context: "formatting" });
        case "eeeee":
          return match2.day(string, { width: "narrow", context: "formatting" });
        case "eeeeee":
          return match2.day(string, { width: "short", context: "formatting" }) || match2.day(string, { width: "narrow", context: "formatting" });
        case "eeee":
        default:
          return match2.day(string, { width: "wide", context: "formatting" }) || match2.day(string, { width: "abbreviated", context: "formatting" }) || match2.day(string, { width: "short", context: "formatting" }) || match2.day(string, { width: "narrow", context: "formatting" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 6;
    },
    set: function(date, value, options2) {
      date = setUTCDay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // Stand-alone local day of week
  c: {
    priority: 90,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return parseNDigits(token.length, string, valueCallback);
        case "co":
          return match2.ordinalNumber(string, { unit: "day", valueCallback });
        case "ccc":
          return match2.day(string, { width: "abbreviated", context: "standalone" }) || match2.day(string, { width: "short", context: "standalone" }) || match2.day(string, { width: "narrow", context: "standalone" });
        case "ccccc":
          return match2.day(string, { width: "narrow", context: "standalone" });
        case "cccccc":
          return match2.day(string, { width: "short", context: "standalone" }) || match2.day(string, { width: "narrow", context: "standalone" });
        case "cccc":
        default:
          return match2.day(string, { width: "wide", context: "standalone" }) || match2.day(string, { width: "abbreviated", context: "standalone" }) || match2.day(string, { width: "short", context: "standalone" }) || match2.day(string, { width: "narrow", context: "standalone" });
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 6;
    },
    set: function(date, value, options2) {
      date = setUTCDay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // ISO day of week
  i: {
    priority: 90,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, string);
        case "io":
          return match2.ordinalNumber(string, { unit: "day" });
        case "iii":
          return match2.day(string, { width: "abbreviated", context: "formatting", valueCallback }) || match2.day(string, { width: "short", context: "formatting", valueCallback }) || match2.day(string, { width: "narrow", context: "formatting", valueCallback });
        case "iiiii":
          return match2.day(string, { width: "narrow", context: "formatting", valueCallback });
        case "iiiiii":
          return match2.day(string, { width: "short", context: "formatting", valueCallback }) || match2.day(string, { width: "narrow", context: "formatting", valueCallback });
        case "iiii":
        default:
          return match2.day(string, { width: "wide", context: "formatting", valueCallback }) || match2.day(string, { width: "abbreviated", context: "formatting", valueCallback }) || match2.day(string, { width: "short", context: "formatting", valueCallback }) || match2.day(string, { width: "narrow", context: "formatting", valueCallback });
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 7;
    },
    set: function(date, value, options2) {
      date = setUTCISODay(date, value, options2);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  },
  // AM or PM
  a: {
    priority: 80,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(string, { width: "abbreviated", context: "formatting" }) || match2.dayPeriod(string, { width: "narrow", context: "formatting" });
        case "aaaaa":
          return match2.dayPeriod(string, { width: "narrow", context: "formatting" });
        case "aaaa":
        default:
          return match2.dayPeriod(string, { width: "wide", context: "formatting" }) || match2.dayPeriod(string, { width: "abbreviated", context: "formatting" }) || match2.dayPeriod(string, { width: "narrow", context: "formatting" });
      }
    },
    set: function(date, value, options2) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  },
  // AM, PM, midnight
  b: {
    priority: 80,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(string, { width: "abbreviated", context: "formatting" }) || match2.dayPeriod(string, { width: "narrow", context: "formatting" });
        case "bbbbb":
          return match2.dayPeriod(string, { width: "narrow", context: "formatting" });
        case "bbbb":
        default:
          return match2.dayPeriod(string, { width: "wide", context: "formatting" }) || match2.dayPeriod(string, { width: "abbreviated", context: "formatting" }) || match2.dayPeriod(string, { width: "narrow", context: "formatting" });
      }
    },
    set: function(date, value, options2) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: {
    priority: 80,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(string, { width: "abbreviated", context: "formatting" }) || match2.dayPeriod(string, { width: "narrow", context: "formatting" });
        case "BBBBB":
          return match2.dayPeriod(string, { width: "narrow", context: "formatting" });
        case "BBBB":
        default:
          return match2.dayPeriod(string, { width: "wide", context: "formatting" }) || match2.dayPeriod(string, { width: "abbreviated", context: "formatting" }) || match2.dayPeriod(string, { width: "narrow", context: "formatting" });
      }
    },
    set: function(date, value, options2) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  },
  // Hour [1-12]
  h: {
    priority: 70,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, string);
        case "ho":
          return match2.ordinalNumber(string, { unit: "hour" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 12;
    },
    set: function(date, value, options2) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  },
  // Hour [0-23]
  H: {
    priority: 70,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, string);
        case "Ho":
          return match2.ordinalNumber(string, { unit: "hour" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 23;
    },
    set: function(date, value, options2) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  },
  // Hour [0-11]
  K: {
    priority: 70,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, string);
        case "Ko":
          return match2.ordinalNumber(string, { unit: "hour" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 11;
    },
    set: function(date, value, options2) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  },
  // Hour [1-24]
  k: {
    priority: 70,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, string);
        case "ko":
          return match2.ordinalNumber(string, { unit: "hour" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 1 && value <= 24;
    },
    set: function(date, value, options2) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  },
  // Minute
  m: {
    priority: 60,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, string);
        case "mo":
          return match2.ordinalNumber(string, { unit: "minute" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 59;
    },
    set: function(date, value, options2) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  },
  // Second
  s: {
    priority: 50,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, string);
        case "so":
          return match2.ordinalNumber(string, { unit: "second" });
        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function(date, value, options2) {
      return value >= 0 && value <= 59;
    },
    set: function(date, value, options2) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  },
  // Fraction of second
  S: {
    priority: 40,
    parse: function(string, token, match2, options2) {
      var valueCallback = function(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return parseNDigits(token.length, string, valueCallback);
    },
    set: function(date, value, options2) {
      date.setUTCMilliseconds(value);
      return date;
    }
  },
  // Timezone (ISO-8601. +00:00 is `'Z'`)
  X: {
    priority: 20,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, value, options2) {
      return new Date(date.getTime() - value);
    }
  },
  // Timezone (ISO-8601)
  x: {
    priority: 20,
    parse: function(string, token, match2, options2) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, string);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function(date, value, options2) {
      return new Date(date.getTime() - value);
    }
  },
  // Seconds timestamp
  t: {
    priority: 10,
    parse: function(string, token, match2, options2) {
      return parseAnyDigitsSigned(string);
    },
    set: function(date, value, options2) {
      return new Date(value * 1e3);
    }
  },
  // Milliseconds timestamp
  T: {
    priority: 10,
    parse: function(string, token, match2, options2) {
      return parseAnyDigitsSigned(string);
    },
    set: function(date, value, options2) {
      return new Date(value);
    }
  }
};
var TIMEZONE_UNIT_PRIORITY = 20;
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'(.*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var notWhitespaceRegExp = /\S/;
function parse(dirtyDateString, dirtyFormatString, dirtyBaseDate, dirtyOptions) {
  if (arguments.length < 3) {
    throw new TypeError(
      "3 arguments required, but only " + arguments.length + " present"
    );
  }
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale || locale$1;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError(
      "firstWeekContainsDate must be between 1 and 7 inclusively"
    );
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyBaseDate, options2);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [
    {
      priority: TIMEZONE_UNIT_PRIORITY,
      set: dateToSystemTimezone,
      index: 0
    }
  ];
  var i;
  var tokens = formatString.match(formattingTokensRegExp$1);
  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (!options2.awareOfUnicodeTokens && isProtectedToken(token)) {
      throwProtectedError(token);
    }
    var firstCharacter = token[0];
    var parser = parsers[firstCharacter];
    if (parser) {
      var parseResult = parser.parse(
        dateString,
        token,
        locale2.match,
        subFnOptions
      );
      if (!parseResult) {
        return /* @__PURE__ */ new Date(NaN);
      }
      setters.push({
        priority: parser.priority,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString$1(token);
      }
      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a, b) {
    return b - a;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).reverse();
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyBaseDate, options2);
  if (isNaN(date)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];
    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    utcDate = setter.set(utcDate, setter.value, subFnOptions);
  }
  return utcDate;
}
function dateToSystemTimezone(date) {
  var convertedDate = /* @__PURE__ */ new Date(0);
  convertedDate.setFullYear(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate()
  );
  convertedDate.setHours(
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  );
  return convertedDate;
}
function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}
function parseDate$1(date, format$1) {
  if (typeof date !== "string") {
    return isValid(date) ? date : null;
  }
  var parsed = parse(date, format$1, /* @__PURE__ */ new Date());
  if (!isValid(parsed) || format(parsed, format$1) !== date) {
    return null;
  }
  return parsed;
}
var afterValidator = function(value, ref) {
  if (ref === void 0) ref = {};
  var targetValue = ref.targetValue;
  var inclusion = ref.inclusion;
  if (inclusion === void 0) inclusion = false;
  var format2 = ref.format;
  if (typeof format2 === "undefined") {
    format2 = inclusion;
    inclusion = false;
  }
  value = parseDate$1(value, format2);
  targetValue = parseDate$1(targetValue, format2);
  if (!value || !targetValue) {
    return false;
  }
  return isAfter(value, targetValue) || inclusion && isEqual$1(value, targetValue);
};
var options = {
  hasTarget: true,
  isDate: true
};
var paramNames = ["targetValue", "inclusion", "format"];
var after = {
  validate: afterValidator,
  options,
  paramNames
};
var alpha = {
  en: /^[A-Z]*$/i,
  cs: /^[A-Z]*$/i,
  da: /^[A-Z]*$/i,
  de: /^[A-Z]*$/i,
  es: /^[A-Z]*$/i,
  fa: /^[]*$/,
  fr: /^[A-Z]*$/i,
  it: /^[A-Z\xC0-\xFF]*$/i,
  lt: /^[A-Z]*$/i,
  nl: /^[A-Z]*$/i,
  hu: /^[A-Z]*$/i,
  pl: /^[A-Z]*$/i,
  pt: /^[A-Z]*$/i,
  ru: /^[-]*$/i,
  sk: /^[A-Z]*$/i,
  sr: /^[A-Z]*$/i,
  sv: /^[A-Z]*$/i,
  tr: /^[A-Z]*$/i,
  uk: /^[-]*$/i,
  ar: /^[]*$/,
  az: /^[A-Z]*$/i
};
var alphaSpaces = {
  en: /^[A-Z\s]*$/i,
  cs: /^[A-Z\s]*$/i,
  da: /^[A-Z\s]*$/i,
  de: /^[A-Z\s]*$/i,
  es: /^[A-Z\s]*$/i,
  fa: /^[\s]*$/,
  fr: /^[A-Z\s]*$/i,
  it: /^[A-Z\xC0-\xFF\s]*$/i,
  lt: /^[A-Z\s]*$/i,
  nl: /^[A-Z\s]*$/i,
  hu: /^[A-Z\s]*$/i,
  pl: /^[A-Z\s]*$/i,
  pt: /^[A-Z\s]*$/i,
  ru: /^[-\s]*$/i,
  sk: /^[A-Z\s]*$/i,
  sr: /^[A-Z\s]*$/i,
  sv: /^[A-Z\s]*$/i,
  tr: /^[A-Z\s]*$/i,
  uk: /^[-\s]*$/i,
  ar: /^[\s]*$/,
  az: /^[A-Z\s]*$/i
};
var alphanumeric = {
  en: /^[0-9A-Z]*$/i,
  cs: /^[0-9A-Z]*$/i,
  da: /^[0-9A-Z]$/i,
  de: /^[0-9A-Z]*$/i,
  es: /^[0-9A-Z]*$/i,
  fa: /^[0-9]*$/,
  fr: /^[0-9A-Z]*$/i,
  it: /^[0-9A-Z\xC0-\xFF]*$/i,
  lt: /^[0-9A-Z]*$/i,
  hu: /^[0-9A-Z]*$/i,
  nl: /^[0-9A-Z]*$/i,
  pl: /^[0-9A-Z]*$/i,
  pt: /^[0-9A-Z]*$/i,
  ru: /^[0-9-]*$/i,
  sk: /^[0-9A-Z]*$/i,
  sr: /^[0-9A-Z]*$/i,
  sv: /^[0-9A-Z]*$/i,
  tr: /^[0-9A-Z]*$/i,
  uk: /^[0-9-]*$/i,
  ar: /^[0-9]*$/,
  az: /^[0-9A-Z]*$/i
};
var alphaDash = {
  en: /^[0-9A-Z_-]*$/i,
  cs: /^[0-9A-Z_-]*$/i,
  da: /^[0-9A-Z_-]*$/i,
  de: /^[0-9A-Z_-]*$/i,
  es: /^[0-9A-Z_-]*$/i,
  fa: /^[0-9_-]*$/,
  fr: /^[0-9A-Z_-]*$/i,
  it: /^[0-9A-Z\xC0-\xFF_-]*$/i,
  lt: /^[0-9A-Z_-]*$/i,
  nl: /^[0-9A-Z_-]*$/i,
  hu: /^[0-9A-Z_-]*$/i,
  pl: /^[0-9A-Z_-]*$/i,
  pt: /^[0-9A-Z_-]*$/i,
  ru: /^[0-9-_-]*$/i,
  sk: /^[0-9A-Z_-]*$/i,
  sr: /^[0-9A-Z_-]*$/i,
  sv: /^[0-9A-Z_-]*$/i,
  tr: /^[0-9A-Z_-]*$/i,
  uk: /^[0-9-_-]*$/i,
  ar: /^[0-9_-]*$/,
  az: /^[0-9A-Z_-]*$/i
};
var validate3 = function(value, ref) {
  if (ref === void 0) ref = {};
  var locale2 = ref.locale;
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate3(val, [locale2]);
    });
  }
  if (!locale2) {
    return Object.keys(alpha).some(function(loc) {
      return alpha[loc].test(value);
    });
  }
  return (alpha[locale2] || alpha.en).test(value);
};
var paramNames$1 = ["locale"];
var alpha$1 = {
  validate: validate3,
  paramNames: paramNames$1
};
var validate$1 = function(value, ref) {
  if (ref === void 0) ref = {};
  var locale2 = ref.locale;
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$1(val, [locale2]);
    });
  }
  if (!locale2) {
    return Object.keys(alphaDash).some(function(loc) {
      return alphaDash[loc].test(value);
    });
  }
  return (alphaDash[locale2] || alphaDash.en).test(value);
};
var paramNames$2 = ["locale"];
var alpha_dash = {
  validate: validate$1,
  paramNames: paramNames$2
};
var validate$2 = function(value, ref) {
  if (ref === void 0) ref = {};
  var locale2 = ref.locale;
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$2(val, [locale2]);
    });
  }
  if (!locale2) {
    return Object.keys(alphanumeric).some(function(loc) {
      return alphanumeric[loc].test(value);
    });
  }
  return (alphanumeric[locale2] || alphanumeric.en).test(value);
};
var paramNames$3 = ["locale"];
var alpha_num = {
  validate: validate$2,
  paramNames: paramNames$3
};
var validate$3 = function(value, ref) {
  if (ref === void 0) ref = {};
  var locale2 = ref.locale;
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$3(val, [locale2]);
    });
  }
  if (!locale2) {
    return Object.keys(alphaSpaces).some(function(loc) {
      return alphaSpaces[loc].test(value);
    });
  }
  return (alphaSpaces[locale2] || alphaSpaces.en).test(value);
};
var paramNames$4 = ["locale"];
var alpha_spaces = {
  validate: validate$3,
  paramNames: paramNames$4
};
var validate$4 = function(value, ref) {
  if (ref === void 0) ref = {};
  var targetValue = ref.targetValue;
  var inclusion = ref.inclusion;
  if (inclusion === void 0) inclusion = false;
  var format2 = ref.format;
  if (typeof format2 === "undefined") {
    format2 = inclusion;
    inclusion = false;
  }
  value = parseDate$1(value, format2);
  targetValue = parseDate$1(targetValue, format2);
  if (!value || !targetValue) {
    return false;
  }
  return isBefore(value, targetValue) || inclusion && isEqual$1(value, targetValue);
};
var options$1 = {
  hasTarget: true,
  isDate: true
};
var paramNames$5 = ["targetValue", "inclusion", "format"];
var before = {
  validate: validate$4,
  options: options$1,
  paramNames: paramNames$5
};
var validate$5 = function(value, ref) {
  if (ref === void 0) ref = {};
  var min2 = ref.min;
  var max2 = ref.max;
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$5(val, { min: min2, max: max2 });
    });
  }
  return Number(min2) <= value && Number(max2) >= value;
};
var paramNames$6 = ["min", "max"];
var between = {
  validate: validate$5,
  paramNames: paramNames$6
};
var validate$6 = function(value, ref) {
  var targetValue = ref.targetValue;
  return String(value) === String(targetValue);
};
var options$2 = {
  hasTarget: true
};
var paramNames$7 = ["targetValue"];
var confirmed = {
  validate: validate$6,
  options: options$2,
  paramNames: paramNames$7
};
function unwrapExports(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var assertString_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString;
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof2(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  function assertString(input) {
    var isString = typeof input === "string" || input instanceof String;
    if (!isString) {
      var invalidType;
      if (input === null) {
        invalidType = "null";
      } else {
        invalidType = _typeof(input);
        if (invalidType === "object" && input.constructor && input.constructor.hasOwnProperty("name")) {
          invalidType = input.constructor.name;
        } else {
          invalidType = "a ".concat(invalidType);
        }
      }
      throw new TypeError("Expected string but received ".concat(invalidType, "."));
    }
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
unwrapExports(assertString_1);
var isCreditCard_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard2;
  var _assertString = _interopRequireDefault(assertString_1);
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14})$/;
  function isCreditCard2(str) {
    (0, _assertString.default)(str);
    var sanitized = str.replace(/[- ]+/g, "");
    if (!creditCard.test(sanitized)) {
      return false;
    }
    var sum = 0;
    var digit;
    var tmpNum;
    var shouldDouble;
    for (var i = sanitized.length - 1; i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
var isCreditCard = unwrapExports(isCreditCard_1);
var validate$7 = function(value) {
  return isCreditCard(String(value));
};
var credit_card = {
  validate: validate$7
};
var validate$8 = function(value, ref) {
  if (ref === void 0) ref = {};
  var min2 = ref.min;
  var max2 = ref.max;
  var inclusivity = ref.inclusivity;
  if (inclusivity === void 0) inclusivity = "()";
  var format2 = ref.format;
  if (typeof format2 === "undefined") {
    format2 = inclusivity;
    inclusivity = "()";
  }
  var minDate = parseDate$1(String(min2), format2);
  var maxDate = parseDate$1(String(max2), format2);
  var dateVal = parseDate$1(String(value), format2);
  if (!minDate || !maxDate || !dateVal) {
    return false;
  }
  if (inclusivity === "()") {
    return isAfter(dateVal, minDate) && isBefore(dateVal, maxDate);
  }
  if (inclusivity === "(]") {
    return isAfter(dateVal, minDate) && (isEqual$1(dateVal, maxDate) || isBefore(dateVal, maxDate));
  }
  if (inclusivity === "[)") {
    return isBefore(dateVal, maxDate) && (isEqual$1(dateVal, minDate) || isAfter(dateVal, minDate));
  }
  return isEqual$1(dateVal, maxDate) || isEqual$1(dateVal, minDate) || isBefore(dateVal, maxDate) && isAfter(dateVal, minDate);
};
var options$3 = {
  isDate: true
};
var paramNames$8 = ["min", "max", "inclusivity", "format"];
var date_between = {
  validate: validate$8,
  options: options$3,
  paramNames: paramNames$8
};
var validate$9 = function(value, ref) {
  var format2 = ref.format;
  return !!parseDate$1(value, format2);
};
var options$4 = {
  isDate: true
};
var paramNames$9 = ["format"];
var date_format = {
  validate: validate$9,
  options: options$4,
  paramNames: paramNames$9
};
var validate$a = function(value, ref) {
  if (ref === void 0) ref = {};
  var decimals = ref.decimals;
  if (decimals === void 0) decimals = "*";
  var separator = ref.separator;
  if (separator === void 0) separator = ".";
  if (isNullOrUndefined(value) || value === "") {
    return false;
  }
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$a(val, { decimals, separator });
    });
  }
  if (Number(decimals) === 0) {
    return /^-?\d*$/.test(value);
  }
  var regexPart = decimals === "*" ? "+" : "{1," + decimals + "}";
  var regex2 = new RegExp("^[-+]?\\d*(\\" + separator + "\\d" + regexPart + ")?([eE]{1}[-]?\\d+)?$");
  if (!regex2.test(value)) {
    return false;
  }
  var parsedValue = parseFloat(value);
  return parsedValue === parsedValue;
};
var paramNames$a = ["decimals", "separator"];
var decimal = {
  validate: validate$a,
  paramNames: paramNames$a
};
var validate$b = function(value, ref) {
  var length2 = ref[0];
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$b(val, [length2]);
    });
  }
  var strVal = String(value);
  return /^[0-9]*$/.test(strVal) && strVal.length === Number(length2);
};
var digits = {
  validate: validate$b
};
var imageRegex = /\.(jpg|svg|jpeg|png|bmp|gif)$/i;
var validateImage = function(file, width, height) {
  var URL = window.URL || window.webkitURL;
  return new Promise(function(resolve) {
    var image2 = new Image();
    image2.onerror = function() {
      return resolve({ valid: false });
    };
    image2.onload = function() {
      return resolve({
        valid: image2.width === Number(width) && image2.height === Number(height)
      });
    };
    image2.src = URL.createObjectURL(file);
  });
};
var validate$c = function(files, ref) {
  var width = ref[0];
  var height = ref[1];
  var images = ensureArray(files).filter(function(file) {
    return imageRegex.test(file.name);
  });
  if (images.length === 0) {
    return false;
  }
  return Promise.all(images.map(function(image2) {
    return validateImage(image2, width, height);
  }));
};
var dimensions = {
  validate: validate$c
};
var merge_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge2;
  function merge2() {
    var obj2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults = arguments.length > 1 ? arguments[1] : void 0;
    for (var key in defaults) {
      if (typeof obj2[key] === "undefined") {
        obj2[key] = defaults[key];
      }
    }
    return obj2;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
unwrapExports(merge_1);
var isByteLength_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isByteLength;
  var _assertString = _interopRequireDefault(assertString_1);
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  function _typeof(obj2) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj3) {
        return typeof obj3;
      };
    } else {
      _typeof = function _typeof2(obj3) {
        return obj3 && typeof Symbol === "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
      };
    }
    return _typeof(obj2);
  }
  function isByteLength(str, options2) {
    (0, _assertString.default)(str);
    var min2;
    var max2;
    if (_typeof(options2) === "object") {
      min2 = options2.min || 0;
      max2 = options2.max;
    } else {
      min2 = arguments[1];
      max2 = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min2 && (typeof max2 === "undefined" || len <= max2);
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
unwrapExports(isByteLength_1);
var isFQDN_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN2;
  var _assertString = _interopRequireDefault(assertString_1);
  var _merge2 = _interopRequireDefault(merge_1);
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false
  };
  function isFQDN2(str, options2) {
    (0, _assertString.default)(str);
    options2 = (0, _merge2.default)(options2, default_fqdn_options);
    if (options2.allow_trailing_dot && str[str.length - 1] === ".") {
      str = str.substring(0, str.length - 1);
    }
    var parts = str.split(".");
    for (var i = 0; i < parts.length; i++) {
      if (parts[i].length > 63) {
        return false;
      }
    }
    if (options2.require_tld) {
      var tld = parts.pop();
      if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/[\s\u2002-\u200B\u202F\u205F\u3000\uFEFF\uDB40\uDC20]/.test(tld)) {
        return false;
      }
    }
    for (var part, _i = 0; _i < parts.length; _i++) {
      part = parts[_i];
      if (options2.allow_underscores) {
        part = part.replace(/_/g, "");
      }
      if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (part[0] === "-" || part[part.length - 1] === "-") {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
var isFQDN = unwrapExports(isFQDN_1);
var isIP_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP2;
  var _assertString = _interopRequireDefault(assertString_1);
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var ipv4Maybe = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
  var ipv6Block = /^[0-9A-F]{1,4}$/i;
  function isIP2(str) {
    var version2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (0, _assertString.default)(str);
    version2 = String(version2);
    if (!version2) {
      return isIP2(str, 4) || isIP2(str, 6);
    } else if (version2 === "4") {
      if (!ipv4Maybe.test(str)) {
        return false;
      }
      var parts = str.split(".").sort(function(a, b) {
        return a - b;
      });
      return parts[3] <= 255;
    } else if (version2 === "6") {
      var blocks = str.split(":");
      var foundOmissionBlock = false;
      var foundIPv4TransitionBlock = isIP2(blocks[blocks.length - 1], 4);
      var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;
      if (blocks.length > expectedNumberOfBlocks) {
        return false;
      }
      if (str === "::") {
        return true;
      } else if (str.substr(0, 2) === "::") {
        blocks.shift();
        blocks.shift();
        foundOmissionBlock = true;
      } else if (str.substr(str.length - 2) === "::") {
        blocks.pop();
        blocks.pop();
        foundOmissionBlock = true;
      }
      for (var i = 0; i < blocks.length; ++i) {
        if (blocks[i] === "" && i > 0 && i < blocks.length - 1) {
          if (foundOmissionBlock) {
            return false;
          }
          foundOmissionBlock = true;
        } else if (foundIPv4TransitionBlock && i === blocks.length - 1) ;
        else if (!ipv6Block.test(blocks[i])) {
          return false;
        }
      }
      if (foundOmissionBlock) {
        return blocks.length >= 1;
      }
      return blocks.length === expectedNumberOfBlocks;
    }
    return false;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
var isIP = unwrapExports(isIP_1);
var isEmail_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail2;
  var _assertString = _interopRequireDefault(assertString_1);
  var _merge2 = _interopRequireDefault(merge_1);
  var _isByteLength = _interopRequireDefault(isByteLength_1);
  var _isFQDN = _interopRequireDefault(isFQDN_1);
  var _isIP = _interopRequireDefault(isIP_1);
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var default_email_options = {
    allow_display_name: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true
  };
  var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\,\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  function isEmail2(str, options2) {
    (0, _assertString.default)(str);
    options2 = (0, _merge2.default)(options2, default_email_options);
    if (options2.require_display_name || options2.allow_display_name) {
      var display_email = str.match(displayName);
      if (display_email) {
        str = display_email[1];
      } else if (options2.require_display_name) {
        return false;
      }
    }
    var parts = str.split("@");
    var domain = parts.pop();
    var user = parts.join("@");
    var lower_domain = domain.toLowerCase();
    if (options2.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
      user = user.toLowerCase();
      var username = user.split("+")[0];
      if (!(0, _isByteLength.default)(username.replace(".", ""), {
        min: 6,
        max: 30
      })) {
        return false;
      }
      var _user_parts = username.split(".");
      for (var i = 0; i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }
    if (!(0, _isByteLength.default)(user, {
      max: 64
    }) || !(0, _isByteLength.default)(domain, {
      max: 254
    })) {
      return false;
    }
    if (!(0, _isFQDN.default)(domain, {
      require_tld: options2.require_tld
    })) {
      if (!options2.allow_ip_domain) {
        return false;
      }
      if (!(0, _isIP.default)(domain)) {
        if (!domain.startsWith("[") || !domain.endsWith("]")) {
          return false;
        }
        var noBracketdomain = domain.substr(1, domain.length - 2);
        if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
          return false;
        }
      }
    }
    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options2.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }
    var pattern = options2.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split(".");
    for (var _i = 0; _i < user_parts.length; _i++) {
      if (!pattern.test(user_parts[_i])) {
        return false;
      }
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
var isEmail = unwrapExports(isEmail_1);
function objectWithoutProperties(obj2, exclude) {
  var target = {};
  for (var k in obj2) if (Object.prototype.hasOwnProperty.call(obj2, k) && exclude.indexOf(k) === -1) target[k] = obj2[k];
  return target;
}
var validate$d = function(value, ref) {
  if (ref === void 0) ref = {};
  var multiple = ref.multiple;
  if (multiple === void 0) multiple = false;
  var rest = objectWithoutProperties(ref, ["multiple"]);
  var options2 = rest;
  if (multiple && !Array.isArray(value)) {
    value = String(value).split(",").map(function(emailStr) {
      return emailStr.trim();
    });
  }
  var validatorOptions = assign({}, options2);
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return isEmail(String(val), validatorOptions);
    });
  }
  return isEmail(String(value), validatorOptions);
};
var email = {
  validate: validate$d
};
var validate$e = function(value, options2) {
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$e(val, options2);
    });
  }
  return toArray(options2).some(function(item) {
    return item == value;
  });
};
var included = {
  validate: validate$e
};
var validate$f = function() {
  var args = [], len = arguments.length;
  while (len--) args[len] = arguments[len];
  return !validate$e.apply(void 0, args);
};
var excluded = {
  validate: validate$f
};
var validate$g = function(files, extensions) {
  var regex2 = new RegExp(".(" + extensions.join("|") + ")$", "i");
  return ensureArray(files).every(function(file) {
    return regex2.test(file.name);
  });
};
var ext = {
  validate: validate$g
};
var validate$h = function(files) {
  return (Array.isArray(files) ? files : [files]).every(function(file) {
    return /\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(file.name);
  });
};
var image = {
  validate: validate$h
};
var validate$i = function(value) {
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return /^-?[0-9]+$/.test(String(val));
    });
  }
  return /^-?[0-9]+$/.test(String(value));
};
var integer = {
  validate: validate$i
};
var validate$j = function(value, ref) {
  if (ref === void 0) ref = {};
  var version2 = ref.version;
  if (version2 === void 0) version2 = 4;
  if (isNullOrUndefined(value)) {
    value = "";
  }
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return isIP(val, version2);
    });
  }
  return isIP(value, version2);
};
var paramNames$b = ["version"];
var ip = {
  validate: validate$j,
  paramNames: paramNames$b
};
var validate$k = function(value) {
  if (isNullOrUndefined(value)) {
    value = "";
  }
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return isIP(val, "") || isFQDN(val);
    });
  }
  return isIP(value, "") || isFQDN(value);
};
var ip_or_fqdn = {
  validate: validate$k
};
var validate$l = function(value, ref) {
  if (ref === void 0) ref = [];
  var other = ref[0];
  return value === other;
};
var is = {
  validate: validate$l
};
var validate$m = function(value, ref) {
  if (ref === void 0) ref = [];
  var other = ref[0];
  return value !== other;
};
var is_not = {
  validate: validate$m
};
var compare = function(value, length2, max2) {
  if (max2 === void 0) {
    return value.length === length2;
  }
  max2 = Number(max2);
  return value.length >= length2 && value.length <= max2;
};
var validate$n = function(value, ref) {
  var length2 = ref[0];
  var max2 = ref[1];
  if (max2 === void 0) max2 = void 0;
  if (isNullOrUndefined(value)) {
    return false;
  }
  length2 = Number(length2);
  if (typeof value === "number") {
    value = String(value);
  }
  if (!value.length) {
    value = toArray(value);
  }
  return compare(value, length2, max2);
};
var length = {
  validate: validate$n
};
var validate$o = function(value, ref) {
  var length2 = ref[0];
  if (isNullOrUndefined(value)) {
    return length2 >= 0;
  }
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$o(val, [length2]);
    });
  }
  return String(value).length <= length2;
};
var max = {
  validate: validate$o
};
var validate$p = function(value, ref) {
  var max2 = ref[0];
  if (isNullOrUndefined(value) || value === "") {
    return false;
  }
  if (Array.isArray(value)) {
    return value.length > 0 && value.every(function(val) {
      return validate$p(val, [max2]);
    });
  }
  return Number(value) <= max2;
};
var max_value = {
  validate: validate$p
};
var validate$q = function(files, mimes2) {
  var regex2 = new RegExp(mimes2.join("|").replace("*", ".+") + "$", "i");
  return ensureArray(files).every(function(file) {
    return regex2.test(file.type);
  });
};
var mimes = {
  validate: validate$q
};
var validate$r = function(value, ref) {
  var length2 = ref[0];
  if (isNullOrUndefined(value)) {
    return false;
  }
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$r(val, [length2]);
    });
  }
  return String(value).length >= length2;
};
var min = {
  validate: validate$r
};
var validate$s = function(value, ref) {
  var min2 = ref[0];
  if (isNullOrUndefined(value) || value === "") {
    return false;
  }
  if (Array.isArray(value)) {
    return value.length > 0 && value.every(function(val) {
      return validate$s(val, [min2]);
    });
  }
  return Number(value) >= min2;
};
var min_value = {
  validate: validate$s
};
var ar = /^[]+$/;
var en = /^[0-9]+$/;
var validate$t = function(value) {
  var testValue = function(val) {
    var strValue = String(val);
    return en.test(strValue) || ar.test(strValue);
  };
  if (Array.isArray(value)) {
    return value.every(testValue);
  }
  return testValue(value);
};
var numeric = {
  validate: validate$t
};
var validate$u = function(value, ref) {
  var expression = ref.expression;
  if (typeof expression === "string") {
    expression = new RegExp(expression);
  }
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return validate$u(val, { expression });
    });
  }
  return expression.test(String(value));
};
var paramNames$c = ["expression"];
var regex = {
  validate: validate$u,
  paramNames: paramNames$c
};
var validate$v = function(value, ref) {
  if (ref === void 0) ref = [];
  var invalidateFalse = ref[0];
  if (invalidateFalse === void 0) invalidateFalse = false;
  if (isNullOrUndefined(value) || isEmptyArray(value)) {
    return false;
  }
  if (value === false && invalidateFalse) {
    return false;
  }
  return !!String(value).trim().length;
};
var required = {
  validate: validate$v
};
var validate$w = function(value, ref) {
  if (ref === void 0) ref = [];
  var otherFieldVal = ref[0];
  var possibleVals = ref.slice(1);
  var required2 = possibleVals.includes(String(otherFieldVal).trim());
  if (!required2) {
    return {
      valid: true,
      data: {
        required: required2
      }
    };
  }
  var invalid = isEmptyArray(value) || [false, null, void 0].includes(value);
  invalid = invalid || !String(value).trim().length;
  return {
    valid: !invalid,
    data: {
      required: required2
    }
  };
};
var options$5 = {
  hasTarget: true,
  computesRequired: true
};
var required_if = {
  validate: validate$w,
  options: options$5
};
var validate$x = function(files, ref) {
  var size2 = ref[0];
  if (isNaN(size2)) {
    return false;
  }
  var nSize = Number(size2) * 1024;
  return ensureArray(files).every(function(file) {
    return file.size <= nSize;
  });
};
var size = {
  validate: validate$x
};
var isURL_1 = createCommonjsModule(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL2;
  var _assertString = _interopRequireDefault(assertString_1);
  var _isFQDN = _interopRequireDefault(isFQDN_1);
  var _isIP = _interopRequireDefault(isIP_1);
  var _merge2 = _interopRequireDefault(merge_1);
  function _interopRequireDefault(obj2) {
    return obj2 && obj2.__esModule ? obj2 : { default: obj2 };
  }
  var default_url_options = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  function isRegExp(obj2) {
    return Object.prototype.toString.call(obj2) === "[object RegExp]";
  }
  function checkHost(host, matches2) {
    for (var i = 0; i < matches2.length; i++) {
      var match2 = matches2[i];
      if (host === match2 || isRegExp(match2) && match2.test(host)) {
        return true;
      }
    }
    return false;
  }
  function isURL2(url2, options2) {
    (0, _assertString.default)(url2);
    if (!url2 || url2.length >= 2083 || /[\s<>]/.test(url2)) {
      return false;
    }
    if (url2.indexOf("mailto:") === 0) {
      return false;
    }
    options2 = (0, _merge2.default)(options2, default_url_options);
    var protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = url2.split("#");
    url2 = split.shift();
    split = url2.split("?");
    url2 = split.shift();
    split = url2.split("://");
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options2.require_valid_protocol && options2.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options2.require_protocol) {
      return false;
    } else if (url2.substr(0, 2) === "//") {
      if (!options2.allow_protocol_relative_urls) {
        return false;
      }
      split[0] = url2.substr(2);
    }
    url2 = split.join("://");
    if (url2 === "") {
      return false;
    }
    split = url2.split("/");
    url2 = split.shift();
    if (url2 === "" && !options2.require_host) {
      return true;
    }
    split = url2.split("@");
    if (split.length > 1) {
      if (options2.disallow_auth) {
        return false;
      }
      auth = split.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
    }
    hostname = split.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(":");
      host = split.shift();
      if (split.length) {
        port_str = split.join(":");
      }
    }
    if (port_str !== null) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options2) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options2.host_whitelist && !checkHost(host, options2.host_whitelist)) {
      return false;
    }
    if (options2.host_blacklist && checkHost(host, options2.host_blacklist)) {
      return false;
    }
    return true;
  }
  module.exports = exports.default;
  module.exports.default = exports.default;
});
var isURL = unwrapExports(isURL_1);
var validate$y = function(value, options2) {
  if (options2 === void 0) options2 = {};
  if (isNullOrUndefined(value)) {
    value = "";
  }
  var validatorOptions = assign({}, options2);
  if (Array.isArray(value)) {
    return value.every(function(val) {
      return isURL(val, validatorOptions);
    });
  }
  return isURL(value, validatorOptions);
};
var url = {
  validate: validate$y
};
var Rules = Object.freeze({
  after,
  alpha_dash,
  alpha_num,
  alpha_spaces,
  alpha: alpha$1,
  before,
  between,
  confirmed,
  credit_card,
  date_between,
  date_format,
  decimal,
  digits,
  dimensions,
  email,
  ext,
  image,
  included,
  integer,
  length,
  ip,
  ip_or_fqdn,
  is_not,
  is,
  max,
  max_value,
  mimes,
  min,
  min_value,
  excluded,
  numeric,
  regex,
  required,
  required_if,
  size,
  url
});
var normalize = function(fields) {
  if (Array.isArray(fields)) {
    return fields.reduce(function(prev, curr) {
      if (includes(curr, ".")) {
        prev[curr.split(".")[1]] = curr;
      } else {
        prev[curr] = curr;
      }
      return prev;
    }, {});
  }
  return fields;
};
var combine = function(lhs, rhs) {
  var mapper = {
    pristine: function(lhs2, rhs2) {
      return lhs2 && rhs2;
    },
    dirty: function(lhs2, rhs2) {
      return lhs2 || rhs2;
    },
    touched: function(lhs2, rhs2) {
      return lhs2 || rhs2;
    },
    untouched: function(lhs2, rhs2) {
      return lhs2 && rhs2;
    },
    valid: function(lhs2, rhs2) {
      return lhs2 && rhs2;
    },
    invalid: function(lhs2, rhs2) {
      return lhs2 || rhs2;
    },
    pending: function(lhs2, rhs2) {
      return lhs2 || rhs2;
    },
    required: function(lhs2, rhs2) {
      return lhs2 || rhs2;
    },
    validated: function(lhs2, rhs2) {
      return lhs2 && rhs2;
    }
  };
  return Object.keys(mapper).reduce(function(flags, flag3) {
    flags[flag3] = mapper[flag3](lhs[flag3], rhs[flag3]);
    return flags;
  }, {});
};
var mapScope = function(scope, deep) {
  if (deep === void 0) deep = true;
  return Object.keys(scope).reduce(function(flags, field) {
    if (!flags) {
      flags = assign({}, scope[field]);
      return flags;
    }
    var isScope = field.indexOf("$") === 0;
    if (deep && isScope) {
      return combine(mapScope(scope[field]), flags);
    } else if (!deep && isScope) {
      return flags;
    }
    flags = combine(flags, scope[field]);
    return flags;
  }, null);
};
var mapFields = function(fields) {
  if (!fields) {
    return function() {
      return mapScope(this.$validator.flags);
    };
  }
  var normalized = normalize(fields);
  return Object.keys(normalized).reduce(function(prev, curr) {
    var field = normalized[curr];
    prev[curr] = function mappedField() {
      if (this.$validator.flags[field]) {
        return this.$validator.flags[field];
      }
      if (normalized[curr] === "*") {
        return mapScope(this.$validator.flags, false);
      }
      var index = field.indexOf(".");
      if (index <= 0) {
        return {};
      }
      var ref = field.split(".");
      var scope = ref[0];
      var name = ref.slice(1);
      scope = this.$validator.flags["$" + scope];
      name = name.join(".");
      if (name === "*" && scope) {
        return mapScope(scope);
      }
      if (scope && scope[name]) {
        return scope[name];
      }
      return {};
    };
    return prev;
  }, {});
};
var $validator = null;
var PROVIDER_COUNTER = 0;
var ValidationProvider = {
  $__veeInject: false,
  inject: {
    $_veeObserver: {
      from: "$_veeObserver",
      default: function default$1() {
        if (!this.$vnode.context.$_veeObserver) {
          this.$vnode.context.$_veeObserver = createObserver();
        }
        return this.$vnode.context.$_veeObserver;
      }
    }
  },
  props: {
    vid: {
      type: [String, Number],
      default: function() {
        PROVIDER_COUNTER++;
        return "_vee_" + PROVIDER_COUNTER;
      }
    },
    name: {
      type: String,
      default: null
    },
    mode: {
      type: [String, Function],
      default: function() {
        return getConfig().mode;
      }
    },
    events: {
      type: Array,
      validate: function() {
        if (true) {
          warn("events prop and config will be deprecated in future version please use the interaction modes instead");
        }
        return true;
      },
      default: function() {
        var events = getConfig().events;
        if (typeof events === "string") {
          return events.split("|");
        }
        return events;
      }
    },
    rules: {
      type: [Object, String],
      default: null
    },
    immediate: {
      type: Boolean,
      default: false
    },
    persist: {
      type: Boolean,
      default: false
    },
    bails: {
      type: Boolean,
      default: function() {
        return getConfig().fastExit;
      }
    },
    debounce: {
      type: Number,
      default: function() {
        return getConfig().delay || 0;
      }
    },
    tag: {
      type: String,
      default: "span"
    },
    slim: {
      type: Boolean,
      default: false
    }
  },
  watch: {
    rules: {
      deep: true,
      handler: function handler(val, oldVal) {
        this._needsValidation = !isEqual(val, oldVal);
      }
    }
  },
  data: function() {
    return {
      messages: [],
      value: void 0,
      initialized: false,
      initialValue: void 0,
      flags: createFlags(),
      failedRules: {},
      forceRequired: false,
      isDeactivated: false,
      id: null
    };
  },
  computed: {
    isValid: function isValid2() {
      return this.flags.valid;
    },
    fieldDeps: function fieldDeps() {
      var this$1 = this;
      var rules = normalizeRules(this.rules);
      return Object.keys(rules).filter(RuleContainer.isTargetRule).map(function(rule) {
        var depName = rules[rule][0];
        watchCrossFieldDep(this$1, depName);
        return depName;
      });
    },
    normalizedEvents: function normalizedEvents() {
      var this$1 = this;
      var ref = computeModeSetting(this);
      var on = ref.on;
      return normalizeEvents(on || this.events || []).map(function(e) {
        if (e === "input") {
          return this$1._inputEventName;
        }
        return e;
      });
    },
    isRequired: function isRequired() {
      var rules = normalizeRules(this.rules);
      var forceRequired = this.forceRequired;
      var isRequired2 = rules.required || forceRequired;
      this.flags.required = isRequired2;
      return isRequired2;
    },
    classes: function classes() {
      var this$1 = this;
      var names = getConfig().classNames;
      return Object.keys(this.flags).reduce(function(classes2, flag3) {
        var className = names && names[flag3] || flag3;
        if (isNullOrUndefined(this$1.flags[flag3])) {
          return classes2;
        }
        if (className) {
          classes2[className] = this$1.flags[flag3];
        }
        return classes2;
      }, {});
    }
  },
  render: function render(h) {
    var this$1 = this;
    this.registerField();
    var ctx2 = createValidationCtx(this);
    var slot = this.$scopedSlots.default;
    if (!isCallable(slot)) {
      if (true) {
        warn('ValidationProvider expects a scoped slot. Did you forget to add "v-slot" to your slot?');
      }
      return h(this.tag, this.$slots.default);
    }
    var nodes = slot(ctx2);
    extractVNodes(nodes).forEach(function(input) {
      addListeners.call(this$1, input);
    });
    return this.slim ? createRenderless(h, nodes) : h(this.tag, nodes);
  },
  beforeDestroy: function beforeDestroy2() {
    this.$_veeObserver.unsubscribe(this);
  },
  activated: function activated() {
    this.$_veeObserver.subscribe(this);
    this.isDeactivated = false;
  },
  deactivated: function deactivated() {
    this.$_veeObserver.unsubscribe(this);
    this.isDeactivated = true;
  },
  methods: {
    setFlags: function setFlags2(flags) {
      var this$1 = this;
      Object.keys(flags).forEach(function(flag3) {
        this$1.flags[flag3] = flags[flag3];
      });
    },
    syncValue: function syncValue(e) {
      var value = normalizeValue$1(e);
      this.value = value;
      this.flags.changed = this.initialValue !== value;
    },
    reset: function reset4() {
      this.messages = [];
      this._pendingValidation = null;
      this.initialValue = this.value;
      var flags = createFlags();
      this.setFlags(flags);
    },
    validate: function validate4() {
      var this$1 = this;
      var args = [], len = arguments.length;
      while (len--) args[len] = arguments[len];
      if (args.length > 0) {
        this.syncValue(args[0]);
      }
      return this.validateSilent().then(function(result) {
        this$1.applyResult(result);
        return result;
      });
    },
    validateSilent: function validateSilent() {
      var this$1 = this;
      this.setFlags({ pending: true });
      return $validator.verify(this.value, this.rules, {
        name: this.name,
        values: createValuesLookup(this),
        bails: this.bails
      }).then(function(result) {
        this$1.setFlags({ pending: false });
        if (!this$1.isRequired) {
          this$1.setFlags({ valid: result.valid, invalid: !result.valid });
        }
        return result;
      });
    },
    applyResult: function applyResult(ref) {
      var errors = ref.errors;
      var failedRules = ref.failedRules;
      this.messages = errors;
      this.failedRules = assign({}, failedRules);
      this.setFlags({
        valid: !errors.length,
        changed: this.value !== this.initialValue,
        invalid: !!errors.length,
        validated: true
      });
    },
    registerField: function registerField() {
      if (!$validator) {
        $validator = getValidator() || new Validator(null, { fastExit: getConfig().fastExit });
      }
      updateRenderingContextRefs(this);
    }
  }
};
function createValidationCtx(ctx2) {
  return {
    errors: ctx2.messages,
    flags: ctx2.flags,
    classes: ctx2.classes,
    valid: ctx2.isValid,
    failedRules: ctx2.failedRules,
    reset: function() {
      return ctx2.reset();
    },
    validate: function() {
      var args = [], len = arguments.length;
      while (len--) args[len] = arguments[len];
      return ctx2.validate.apply(ctx2, args);
    },
    aria: {
      "aria-invalid": ctx2.flags.invalid ? "true" : "false",
      "aria-required": ctx2.isRequired ? "true" : "false"
    }
  };
}
function normalizeValue$1(value) {
  if (isEvent(value)) {
    return value.target.type === "file" ? toArray(value.target.files) : value.target.value;
  }
  return value;
}
function shouldValidate(ctx2, model) {
  if (!ctx2._ignoreImmediate && ctx2.immediate) {
    return true;
  }
  if (ctx2.value !== model.value) {
    return true;
  }
  if (ctx2._needsValidation) {
    return true;
  }
  if (!ctx2.initialized && model.value === void 0) {
    return true;
  }
  return false;
}
function computeModeSetting(ctx2) {
  var compute = isCallable(ctx2.mode) ? ctx2.mode : modes[ctx2.mode];
  return compute({
    errors: ctx2.messages,
    value: ctx2.value,
    flags: ctx2.flags
  });
}
function onRenderUpdate(model) {
  if (!this.initialized) {
    this.initialValue = model.value;
  }
  var validateNow = shouldValidate(this, model);
  this._needsValidation = false;
  this.value = model.value;
  this._ignoreImmediate = true;
  if (!validateNow) {
    return;
  }
  this.validateSilent().then(this.immediate || this.flags.validated ? this.applyResult : function(x) {
    return x;
  });
}
function createCommonHandlers(ctx2) {
  var onInput = function(e) {
    ctx2.syncValue(e);
    ctx2.setFlags({ dirty: true, pristine: false });
  };
  var onBlur = function() {
    ctx2.setFlags({ touched: true, untouched: false });
  };
  var onValidate = ctx2.$veeHandler;
  var mode = computeModeSetting(ctx2);
  if (!onValidate || ctx2.$veeDebounce !== ctx2.debounce) {
    onValidate = debounce(
      function() {
        ctx2.$nextTick(function() {
          var pendingPromise = ctx2.validateSilent();
          ctx2._pendingValidation = pendingPromise;
          pendingPromise.then(function(result) {
            if (pendingPromise === ctx2._pendingValidation) {
              ctx2.applyResult(result);
              ctx2._pendingValidation = null;
            }
          });
        });
      },
      mode.debounce || ctx2.debounce
    );
    ctx2.$veeHandler = onValidate;
    ctx2.$veeDebounce = ctx2.debounce;
  }
  return { onInput, onBlur, onValidate };
}
function addListeners(node) {
  var model = findModel(node);
  this._inputEventName = this._inputEventName || getInputEventName(node, model);
  onRenderUpdate.call(this, model);
  var ref = createCommonHandlers(this);
  var onInput = ref.onInput;
  var onBlur = ref.onBlur;
  var onValidate = ref.onValidate;
  addVNodeListener(node, this._inputEventName, onInput);
  addVNodeListener(node, "blur", onBlur);
  this.normalizedEvents.forEach(function(evt) {
    addVNodeListener(node, evt, onValidate);
  });
  this.initialized = true;
}
function createValuesLookup(ctx2) {
  var providers = ctx2.$_veeObserver.refs;
  return ctx2.fieldDeps.reduce(function(acc, depName) {
    if (!providers[depName]) {
      return acc;
    }
    acc[depName] = providers[depName].value;
    return acc;
  }, {});
}
function updateRenderingContextRefs(ctx2) {
  if (isNullOrUndefined(ctx2.id) && ctx2.id === ctx2.vid) {
    ctx2.id = PROVIDER_COUNTER;
    PROVIDER_COUNTER++;
  }
  var id2 = ctx2.id;
  var vid = ctx2.vid;
  if (ctx2.isDeactivated || id2 === vid && ctx2.$_veeObserver.refs[id2]) {
    return;
  }
  if (id2 !== vid && ctx2.$_veeObserver.refs[id2] === ctx2) {
    ctx2.$_veeObserver.unsubscribe({ vid: id2 });
  }
  ctx2.$_veeObserver.subscribe(ctx2);
  ctx2.id = vid;
}
function createObserver() {
  return {
    refs: {},
    subscribe: function subscribe2(ctx2) {
      this.refs[ctx2.vid] = ctx2;
    },
    unsubscribe: function unsubscribe2(ctx2) {
      delete this.refs[ctx2.vid];
    }
  };
}
function watchCrossFieldDep(ctx2, depName, withHooks) {
  if (withHooks === void 0) withHooks = true;
  var providers = ctx2.$_veeObserver.refs;
  if (!ctx2._veeWatchers) {
    ctx2._veeWatchers = {};
  }
  if (!providers[depName] && withHooks) {
    return ctx2.$once("hook:mounted", function() {
      watchCrossFieldDep(ctx2, depName, false);
    });
  }
  if (!isCallable(ctx2._veeWatchers[depName]) && providers[depName]) {
    ctx2._veeWatchers[depName] = providers[depName].$watch("value", function() {
      if (ctx2.flags.validated) {
        ctx2._needsValidation = true;
        ctx2.validate();
      }
    });
  }
}
var flagMergingStrategy = {
  pristine: "every",
  dirty: "some",
  touched: "some",
  untouched: "every",
  valid: "every",
  invalid: "some",
  pending: "some",
  validated: "every"
};
function mergeFlags(lhs, rhs, strategy) {
  var stratName = flagMergingStrategy[strategy];
  return [lhs, rhs][stratName](function(f) {
    return f;
  });
}
var OBSERVER_COUNTER = 0;
var ValidationObserver = {
  name: "ValidationObserver",
  provide: function provide2() {
    return {
      $_veeObserver: this
    };
  },
  inject: {
    $_veeObserver: {
      from: "$_veeObserver",
      default: function default$12() {
        if (!this.$vnode.context.$_veeObserver) {
          return null;
        }
        return this.$vnode.context.$_veeObserver;
      }
    }
  },
  props: {
    tag: {
      type: String,
      default: "span"
    },
    slim: {
      type: Boolean,
      default: false
    }
  },
  data: function() {
    return {
      vid: "obs_" + OBSERVER_COUNTER++,
      refs: {},
      observers: [],
      persistedStore: {}
    };
  },
  computed: {
    ctx: function ctx() {
      var this$1 = this;
      var ctx2 = {
        errors: {},
        validate: function(arg) {
          var promise = this$1.validate(arg);
          return {
            then: function then(thenable) {
              return promise.then(function(success) {
                if (success && isCallable(thenable)) {
                  return Promise.resolve(thenable());
                }
                return Promise.resolve(success);
              });
            }
          };
        },
        reset: function() {
          return this$1.reset();
        }
      };
      return values(this.refs).concat(
        Object.keys(this.persistedStore).map(function(key) {
          return {
            vid: key,
            flags: this$1.persistedStore[key].flags,
            messages: this$1.persistedStore[key].errors
          };
        }),
        this.observers
      ).reduce(function(acc, provider) {
        Object.keys(flagMergingStrategy).forEach(function(flag3) {
          var flags = provider.flags || provider.ctx;
          if (!(flag3 in acc)) {
            acc[flag3] = flags[flag3];
            return;
          }
          acc[flag3] = mergeFlags(acc[flag3], flags[flag3], flag3);
        });
        acc.errors[provider.vid] = provider.messages || values(provider.ctx.errors).reduce(function(errs, obsErrors) {
          return errs.concat(obsErrors);
        }, []);
        return acc;
      }, ctx2);
    }
  },
  created: function created() {
    if (this.$_veeObserver) {
      this.$_veeObserver.subscribe(this, "observer");
    }
  },
  activated: function activated2() {
    if (this.$_veeObserver) {
      this.$_veeObserver.subscribe(this, "observer");
    }
  },
  deactivated: function deactivated2() {
    if (this.$_veeObserver) {
      this.$_veeObserver.unsubscribe(this, "observer");
    }
  },
  beforeDestroy: function beforeDestroy3() {
    if (this.$_veeObserver) {
      this.$_veeObserver.unsubscribe(this, "observer");
    }
  },
  render: function render2(h) {
    var slots = this.$slots.default || this.$scopedSlots.default || [];
    if (isCallable(slots)) {
      slots = slots(this.ctx);
    }
    return this.slim ? createRenderless(h, slots) : h(this.tag, { on: this.$listeners, attrs: this.$attrs }, slots);
  },
  methods: {
    subscribe: function subscribe(subscriber, kind) {
      var obj2;
      if (kind === void 0) kind = "provider";
      if (kind === "observer") {
        this.observers.push(subscriber);
        return;
      }
      this.refs = Object.assign({}, this.refs, (obj2 = {}, obj2[subscriber.vid] = subscriber, obj2));
      if (subscriber.persist && this.persistedStore[subscriber.vid]) {
        this.restoreProviderState(subscriber);
      }
    },
    unsubscribe: function unsubscribe(ref, kind) {
      var vid = ref.vid;
      if (kind === void 0) kind = "provider";
      if (kind === "provider") {
        this.removeProvider(vid);
      }
      var idx = findIndex(this.observers, function(o) {
        return o.vid === vid;
      });
      if (idx !== -1) {
        this.observers.splice(idx, 1);
      }
    },
    validate: function validate5(ref) {
      if (ref === void 0) ref = { silent: false };
      var silent = ref.silent;
      return Promise.all(values(this.refs).map(function(ref2) {
        return ref2[silent ? "validateSilent" : "validate"]().then(function(r) {
          return r.valid;
        });
      }).concat(
        this.observers.map(function(obs) {
          return obs.validate({ silent });
        })
      )).then(function(results) {
        return results.every(function(r) {
          return r;
        });
      });
    },
    reset: function reset5() {
      var this$1 = this;
      Object.keys(this.persistedStore).forEach(function(key) {
        this$1.$delete(this$1.persistedStore, key);
      });
      return values(this.refs).concat(this.observers).forEach(function(ref) {
        return ref.reset();
      });
    },
    restoreProviderState: function restoreProviderState(provider) {
      var state = this.persistedStore[provider.vid];
      provider.setFlags(state.flags);
      provider.applyResult(state);
      this.$delete(this.persistedStore, provider.vid);
    },
    removeProvider: function removeProvider(vid) {
      var obj2;
      var provider = this.refs[vid];
      if (provider && provider.persist) {
        if (true) {
          if (vid.indexOf("_vee_") === 0) {
            warn("Please provide a `vid` prop when using `persist`, there might be unexpected issues otherwise.");
          }
        }
        this.persistedStore = assign({}, this.persistedStore, (obj2 = {}, obj2[vid] = {
          flags: provider.flags,
          errors: provider.messages,
          failedRules: provider.failedRules
        }, obj2));
      }
      this.$delete(this.refs, vid);
    }
  }
};
function withValidation(component, ctxToProps) {
  if (ctxToProps === void 0) ctxToProps = null;
  var options2 = isCallable(component) ? component.options : component;
  options2.$__veeInject = false;
  var hoc = {
    name: (options2.name || "AnonymousHoc") + "WithValidation",
    props: assign({}, ValidationProvider.props),
    data: ValidationProvider.data,
    computed: assign({}, ValidationProvider.computed),
    methods: assign({}, ValidationProvider.methods),
    $__veeInject: false,
    beforeDestroy: ValidationProvider.beforeDestroy,
    inject: ValidationProvider.inject
  };
  if (!ctxToProps) {
    ctxToProps = function(ctx2) {
      return ctx2;
    };
  }
  var eventName = options2.model && options2.model.event || "input";
  hoc.render = function(h) {
    var obj2;
    this.registerField();
    var vctx = createValidationCtx(this);
    var listeners = assign({}, this.$listeners);
    var model = findModel(this.$vnode);
    this._inputEventName = this._inputEventName || getInputEventName(this.$vnode, model);
    onRenderUpdate.call(this, model);
    var ref = createCommonHandlers(this);
    var onInput = ref.onInput;
    var onBlur = ref.onBlur;
    var onValidate = ref.onValidate;
    mergeVNodeListeners(listeners, eventName, onInput);
    mergeVNodeListeners(listeners, "blur", onBlur);
    this.normalizedEvents.forEach(function(evt, idx) {
      mergeVNodeListeners(listeners, evt, onValidate);
    });
    var ref$1 = findModelConfig(this.$vnode) || { prop: "value" };
    var prop = ref$1.prop;
    var props = assign({}, this.$attrs, (obj2 = {}, obj2[prop] = model.value, obj2), ctxToProps(vctx));
    return h(options2, {
      attrs: this.$attrs,
      props,
      on: listeners
    }, normalizeSlots(this.$slots, this.$vnode.context));
  };
  return hoc;
}
var version = "2.2.15";
Object.keys(Rules).forEach(function(rule) {
  Validator.extend(rule, Rules[rule].validate, assign({}, Rules[rule].options, { paramNames: Rules[rule].paramNames }));
});
Validator.localize({ en: locale });
var install2 = VeeValidate$1.install;
VeeValidate$1.version = version;
VeeValidate$1.mapFields = mapFields;
VeeValidate$1.ValidationProvider = ValidationProvider;
VeeValidate$1.ValidationObserver = ValidationObserver;
VeeValidate$1.withValidation = withValidation;
var vee_validate_esm_default = VeeValidate$1;
export {
  ErrorBag,
  Rules,
  ValidationObserver,
  ValidationProvider,
  Validator,
  vee_validate_esm_default as default,
  directive,
  install2 as install,
  mapFields,
  mixin,
  version,
  withValidation
};
/*! Bundled license information:

vee-validate/dist/vee-validate.esm.js:
  (**
    * vee-validate v2.2.15
    * (c) 2019 Abdelrahman Awad
    * @license MIT
    *)
*/
//# sourceMappingURL=vee-validate.js.map
